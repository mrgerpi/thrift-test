/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef hotspot_api_TYPES_H
#define hotspot_api_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace hotspot { namespace service {

struct TextType {
  enum type {
    EMPTY = 0,
    COMMON = 1,
    SPACIAL = 2
  };
};

extern const std::map<int, const char*> _TextType_VALUES_TO_NAMES;

class Trace;

class HotspotRequest;

class StationInfo;

class CarpoolEtdInfo;

class HotspotResponse;

class ForecastDepartureTimeRequest;

class ForecastDepartureTimeResponse;

class MatchDetailRequest;

class MatchFeature;

class MatchDetailResponse;

class GetForecastFeatureRequest;

class GetForecastFeatureResponse;

class ProductType;

class PrematchhHoldInfoRequest;

class PrematchHoldRes;

class PrematchhHoldInfoResponse;

class PrematchStationRes;

class PrematchEtdRes;

class PrematchRecommendRequest;

class PrematchRecommendResponse;

class CarpoolEtdRequest;

class CarpoolEtdResponse;

typedef struct _Trace__isset {
  _Trace__isset() : spanId(false), srcMethod(false), hintCode(false), hintContent(false) {}
  bool spanId :1;
  bool srcMethod :1;
  bool hintCode :1;
  bool hintContent :1;
} _Trace__isset;

class Trace {
 public:

  static const char* ascii_fingerprint; // = "8D476629BDA99AC6FA462DCC7E29B166";
  static const uint8_t binary_fingerprint[16]; // = {0x8D,0x47,0x66,0x29,0xBD,0xA9,0x9A,0xC6,0xFA,0x46,0x2D,0xCC,0x7E,0x29,0xB1,0x66};

  Trace(const Trace&);
  Trace& operator=(const Trace&);
  Trace() : logId(), caller(), spanId(), srcMethod(), hintCode(0), hintContent() {
  }

  virtual ~Trace() throw();
  std::string logId;
  std::string caller;
  std::string spanId;
  std::string srcMethod;
  int64_t hintCode;
  std::string hintContent;

  _Trace__isset __isset;

  void __set_logId(const std::string& val);

  void __set_caller(const std::string& val);

  void __set_spanId(const std::string& val);

  void __set_srcMethod(const std::string& val);

  void __set_hintCode(const int64_t val);

  void __set_hintContent(const std::string& val);

  bool operator == (const Trace & rhs) const
  {
    if (!(logId == rhs.logId))
      return false;
    if (!(caller == rhs.caller))
      return false;
    if (__isset.spanId != rhs.__isset.spanId)
      return false;
    else if (__isset.spanId && !(spanId == rhs.spanId))
      return false;
    if (__isset.srcMethod != rhs.__isset.srcMethod)
      return false;
    else if (__isset.srcMethod && !(srcMethod == rhs.srcMethod))
      return false;
    if (__isset.hintCode != rhs.__isset.hintCode)
      return false;
    else if (__isset.hintCode && !(hintCode == rhs.hintCode))
      return false;
    if (__isset.hintContent != rhs.__isset.hintContent)
      return false;
    else if (__isset.hintContent && !(hintContent == rhs.hintContent))
      return false;
    return true;
  }
  bool operator != (const Trace &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Trace & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Trace& obj);
};

void swap(Trace &a, Trace &b);

typedef struct _HotspotRequest__isset {
  _HotspotRequest__isset() : start_uid(false), dest_uid(false), dest_type(false), traceid(false), spanid(false), extends_info(false), city_id(false), lang(false), seat_num_needed(false), extMap(false), bubble_pid(false), station_id(false), start_broadcast_time(false), start_broadcast_time_type(false), trace_info(false) {}
  bool start_uid :1;
  bool dest_uid :1;
  bool dest_type :1;
  bool traceid :1;
  bool spanid :1;
  bool extends_info :1;
  bool city_id :1;
  bool lang :1;
  bool seat_num_needed :1;
  bool extMap :1;
  bool bubble_pid :1;
  bool station_id :1;
  bool start_broadcast_time :1;
  bool start_broadcast_time_type :1;
  bool trace_info :1;
} _HotspotRequest__isset;

class HotspotRequest {
 public:

  static const char* ascii_fingerprint; // = "E08F305EADD2B4C64030803283777B86";
  static const uint8_t binary_fingerprint[16]; // = {0xE0,0x8F,0x30,0x5E,0xAD,0xD2,0xB4,0xC6,0x40,0x30,0x80,0x32,0x83,0x77,0x7B,0x86};

  HotspotRequest(const HotspotRequest&);
  HotspotRequest& operator=(const HotspotRequest&);
  HotspotRequest() : product_id(), acc_key(), app_version(), sdk_type(), client_type(), phone(), pid(), cur_lng(0), cur_lat(0), start_uid(), start_lng(0), start_lat(0), start_type(), start_name(), start_address(), dest_uid(), dest_lng(0), dest_lat(0), dest_type(), dest_name(), dest_address(), cur_step(0), traceid(), spanid(), extends_info(), city_id(0), lang(), seat_num_needed(0), bubble_pid(), station_id(), start_broadcast_time(0), start_broadcast_time_type(0) {
  }

  virtual ~HotspotRequest() throw();
  std::string product_id;
  std::string acc_key;
  std::string app_version;
  std::string sdk_type;
  std::string client_type;
  std::string phone;
  std::string pid;
  double cur_lng;
  double cur_lat;
  std::string start_uid;
  double start_lng;
  double start_lat;
  std::string start_type;
  std::string start_name;
  std::string start_address;
  std::string dest_uid;
  double dest_lng;
  double dest_lat;
  std::string dest_type;
  std::string dest_name;
  std::string dest_address;
  int32_t cur_step;
  std::string traceid;
  std::string spanid;
  std::string extends_info;
  int32_t city_id;
  std::string lang;
  int32_t seat_num_needed;
  std::map<std::string, std::string>  extMap;
  std::string bubble_pid;
  std::string station_id;
  int32_t start_broadcast_time;
  int32_t start_broadcast_time_type;
  Trace trace_info;

  _HotspotRequest__isset __isset;

  void __set_product_id(const std::string& val);

  void __set_acc_key(const std::string& val);

  void __set_app_version(const std::string& val);

  void __set_sdk_type(const std::string& val);

  void __set_client_type(const std::string& val);

  void __set_phone(const std::string& val);

  void __set_pid(const std::string& val);

  void __set_cur_lng(const double val);

  void __set_cur_lat(const double val);

  void __set_start_uid(const std::string& val);

  void __set_start_lng(const double val);

  void __set_start_lat(const double val);

  void __set_start_type(const std::string& val);

  void __set_start_name(const std::string& val);

  void __set_start_address(const std::string& val);

  void __set_dest_uid(const std::string& val);

  void __set_dest_lng(const double val);

  void __set_dest_lat(const double val);

  void __set_dest_type(const std::string& val);

  void __set_dest_name(const std::string& val);

  void __set_dest_address(const std::string& val);

  void __set_cur_step(const int32_t val);

  void __set_traceid(const std::string& val);

  void __set_spanid(const std::string& val);

  void __set_extends_info(const std::string& val);

  void __set_city_id(const int32_t val);

  void __set_lang(const std::string& val);

  void __set_seat_num_needed(const int32_t val);

  void __set_extMap(const std::map<std::string, std::string> & val);

  void __set_bubble_pid(const std::string& val);

  void __set_station_id(const std::string& val);

  void __set_start_broadcast_time(const int32_t val);

  void __set_start_broadcast_time_type(const int32_t val);

  void __set_trace_info(const Trace& val);

  bool operator == (const HotspotRequest & rhs) const
  {
    if (!(product_id == rhs.product_id))
      return false;
    if (!(acc_key == rhs.acc_key))
      return false;
    if (!(app_version == rhs.app_version))
      return false;
    if (!(sdk_type == rhs.sdk_type))
      return false;
    if (!(client_type == rhs.client_type))
      return false;
    if (!(phone == rhs.phone))
      return false;
    if (!(pid == rhs.pid))
      return false;
    if (!(cur_lng == rhs.cur_lng))
      return false;
    if (!(cur_lat == rhs.cur_lat))
      return false;
    if (__isset.start_uid != rhs.__isset.start_uid)
      return false;
    else if (__isset.start_uid && !(start_uid == rhs.start_uid))
      return false;
    if (!(start_lng == rhs.start_lng))
      return false;
    if (!(start_lat == rhs.start_lat))
      return false;
    if (!(start_type == rhs.start_type))
      return false;
    if (!(start_name == rhs.start_name))
      return false;
    if (!(start_address == rhs.start_address))
      return false;
    if (__isset.dest_uid != rhs.__isset.dest_uid)
      return false;
    else if (__isset.dest_uid && !(dest_uid == rhs.dest_uid))
      return false;
    if (!(dest_lng == rhs.dest_lng))
      return false;
    if (!(dest_lat == rhs.dest_lat))
      return false;
    if (__isset.dest_type != rhs.__isset.dest_type)
      return false;
    else if (__isset.dest_type && !(dest_type == rhs.dest_type))
      return false;
    if (!(dest_name == rhs.dest_name))
      return false;
    if (!(dest_address == rhs.dest_address))
      return false;
    if (!(cur_step == rhs.cur_step))
      return false;
    if (__isset.traceid != rhs.__isset.traceid)
      return false;
    else if (__isset.traceid && !(traceid == rhs.traceid))
      return false;
    if (__isset.spanid != rhs.__isset.spanid)
      return false;
    else if (__isset.spanid && !(spanid == rhs.spanid))
      return false;
    if (__isset.extends_info != rhs.__isset.extends_info)
      return false;
    else if (__isset.extends_info && !(extends_info == rhs.extends_info))
      return false;
    if (__isset.city_id != rhs.__isset.city_id)
      return false;
    else if (__isset.city_id && !(city_id == rhs.city_id))
      return false;
    if (__isset.lang != rhs.__isset.lang)
      return false;
    else if (__isset.lang && !(lang == rhs.lang))
      return false;
    if (__isset.seat_num_needed != rhs.__isset.seat_num_needed)
      return false;
    else if (__isset.seat_num_needed && !(seat_num_needed == rhs.seat_num_needed))
      return false;
    if (__isset.extMap != rhs.__isset.extMap)
      return false;
    else if (__isset.extMap && !(extMap == rhs.extMap))
      return false;
    if (__isset.bubble_pid != rhs.__isset.bubble_pid)
      return false;
    else if (__isset.bubble_pid && !(bubble_pid == rhs.bubble_pid))
      return false;
    if (__isset.station_id != rhs.__isset.station_id)
      return false;
    else if (__isset.station_id && !(station_id == rhs.station_id))
      return false;
    if (__isset.start_broadcast_time != rhs.__isset.start_broadcast_time)
      return false;
    else if (__isset.start_broadcast_time && !(start_broadcast_time == rhs.start_broadcast_time))
      return false;
    if (__isset.start_broadcast_time_type != rhs.__isset.start_broadcast_time_type)
      return false;
    else if (__isset.start_broadcast_time_type && !(start_broadcast_time_type == rhs.start_broadcast_time_type))
      return false;
    if (__isset.trace_info != rhs.__isset.trace_info)
      return false;
    else if (__isset.trace_info && !(trace_info == rhs.trace_info))
      return false;
    return true;
  }
  bool operator != (const HotspotRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HotspotRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const HotspotRequest& obj);
};

void swap(HotspotRequest &a, HotspotRequest &b);

typedef struct _StationInfo__isset {
  _StationInfo__isset() : extends_info(false), rec_reason(false), text_type(false), city_id(false), city_name(false) {}
  bool extends_info :1;
  bool rec_reason :1;
  bool text_type :1;
  bool city_id :1;
  bool city_name :1;
} _StationInfo__isset;

class StationInfo {
 public:

  static const char* ascii_fingerprint; // = "8C5E20C7CE5627F1745BC9679FA3AE2A";
  static const uint8_t binary_fingerprint[16]; // = {0x8C,0x5E,0x20,0xC7,0xCE,0x56,0x27,0xF1,0x74,0x5B,0xC9,0x67,0x9F,0xA3,0xAE,0x2A};

  StationInfo(const StationInfo&);
  StationInfo& operator=(const StationInfo&);
  StationInfo() : uid(), lng(0), lat(0), name(), address(), count_down_time(0), walk_distance(0), walk_time(0), is_default(0), extends_info(), rec_reason(), do_pop(0), pop_reason(), text_type((TextType::type)0), city_id(0), city_name() {
  }

  virtual ~StationInfo() throw();
  std::string uid;
  double lng;
  double lat;
  std::string name;
  std::string address;
  std::vector<std::string>  mis_id_list;
  int32_t count_down_time;
  int32_t walk_distance;
  int32_t walk_time;
  bool is_default;
  std::string extends_info;
  std::string rec_reason;
  int32_t do_pop;
  std::string pop_reason;
  TextType::type text_type;
  int32_t city_id;
  std::string city_name;

  _StationInfo__isset __isset;

  void __set_uid(const std::string& val);

  void __set_lng(const double val);

  void __set_lat(const double val);

  void __set_name(const std::string& val);

  void __set_address(const std::string& val);

  void __set_mis_id_list(const std::vector<std::string> & val);

  void __set_count_down_time(const int32_t val);

  void __set_walk_distance(const int32_t val);

  void __set_walk_time(const int32_t val);

  void __set_is_default(const bool val);

  void __set_extends_info(const std::string& val);

  void __set_rec_reason(const std::string& val);

  void __set_do_pop(const int32_t val);

  void __set_pop_reason(const std::string& val);

  void __set_text_type(const TextType::type val);

  void __set_city_id(const int32_t val);

  void __set_city_name(const std::string& val);

  bool operator == (const StationInfo & rhs) const
  {
    if (!(uid == rhs.uid))
      return false;
    if (!(lng == rhs.lng))
      return false;
    if (!(lat == rhs.lat))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(address == rhs.address))
      return false;
    if (!(mis_id_list == rhs.mis_id_list))
      return false;
    if (!(count_down_time == rhs.count_down_time))
      return false;
    if (!(walk_distance == rhs.walk_distance))
      return false;
    if (!(walk_time == rhs.walk_time))
      return false;
    if (!(is_default == rhs.is_default))
      return false;
    if (__isset.extends_info != rhs.__isset.extends_info)
      return false;
    else if (__isset.extends_info && !(extends_info == rhs.extends_info))
      return false;
    if (__isset.rec_reason != rhs.__isset.rec_reason)
      return false;
    else if (__isset.rec_reason && !(rec_reason == rhs.rec_reason))
      return false;
    if (!(do_pop == rhs.do_pop))
      return false;
    if (!(pop_reason == rhs.pop_reason))
      return false;
    if (__isset.text_type != rhs.__isset.text_type)
      return false;
    else if (__isset.text_type && !(text_type == rhs.text_type))
      return false;
    if (__isset.city_id != rhs.__isset.city_id)
      return false;
    else if (__isset.city_id && !(city_id == rhs.city_id))
      return false;
    if (__isset.city_name != rhs.__isset.city_name)
      return false;
    else if (__isset.city_name && !(city_name == rhs.city_name))
      return false;
    return true;
  }
  bool operator != (const StationInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StationInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const StationInfo& obj);
};

void swap(StationInfo &a, StationInfo &b);


class CarpoolEtdInfo {
 public:

  static const char* ascii_fingerprint; // = "F33135321253DAEB67B0E79E416CA831";
  static const uint8_t binary_fingerprint[16]; // = {0xF3,0x31,0x35,0x32,0x12,0x53,0xDA,0xEB,0x67,0xB0,0xE7,0x9E,0x41,0x6C,0xA8,0x31};

  CarpoolEtdInfo(const CarpoolEtdInfo&);
  CarpoolEtdInfo& operator=(const CarpoolEtdInfo&);
  CarpoolEtdInfo() : etdLeftMargin(0), etdRightMargin(0) {
  }

  virtual ~CarpoolEtdInfo() throw();
  int64_t etdLeftMargin;
  int64_t etdRightMargin;

  void __set_etdLeftMargin(const int64_t val);

  void __set_etdRightMargin(const int64_t val);

  bool operator == (const CarpoolEtdInfo & rhs) const
  {
    if (!(etdLeftMargin == rhs.etdLeftMargin))
      return false;
    if (!(etdRightMargin == rhs.etdRightMargin))
      return false;
    return true;
  }
  bool operator != (const CarpoolEtdInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CarpoolEtdInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const CarpoolEtdInfo& obj);
};

void swap(CarpoolEtdInfo &a, CarpoolEtdInfo &b);

typedef struct _HotspotResponse__isset {
  _HotspotResponse__isset() : extends_info(false) {}
  bool extends_info :1;
} _HotspotResponse__isset;

class HotspotResponse {
 public:

  static const char* ascii_fingerprint; // = "4F97F64A1BFAC1E867C68EE96164AB14";
  static const uint8_t binary_fingerprint[16]; // = {0x4F,0x97,0xF6,0x4A,0x1B,0xFA,0xC1,0xE8,0x67,0xC6,0x8E,0xE9,0x61,0x64,0xAB,0x14};

  HotspotResponse(const HotspotResponse&);
  HotspotResponse& operator=(const HotspotResponse&);
  HotspotResponse() : error_code(0), error_msg(), extends_info() {
  }

  virtual ~HotspotResponse() throw();
  int32_t error_code;
  std::string error_msg;
  std::vector<StationInfo>  station_list;
  std::string extends_info;

  _HotspotResponse__isset __isset;

  void __set_error_code(const int32_t val);

  void __set_error_msg(const std::string& val);

  void __set_station_list(const std::vector<StationInfo> & val);

  void __set_extends_info(const std::string& val);

  bool operator == (const HotspotResponse & rhs) const
  {
    if (!(error_code == rhs.error_code))
      return false;
    if (!(error_msg == rhs.error_msg))
      return false;
    if (!(station_list == rhs.station_list))
      return false;
    if (__isset.extends_info != rhs.__isset.extends_info)
      return false;
    else if (__isset.extends_info && !(extends_info == rhs.extends_info))
      return false;
    return true;
  }
  bool operator != (const HotspotResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HotspotResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const HotspotResponse& obj);
};

void swap(HotspotResponse &a, HotspotResponse &b);

typedef struct _ForecastDepartureTimeRequest__isset {
  _ForecastDepartureTimeRequest__isset() : last_ready_departure_time(false), lang(false), extMap(false), cur_lng(false), cur_lat(false), bubble_pid(false), bubble_trace_id(false), appversion(false), product_id(false), trace_info(false) {}
  bool last_ready_departure_time :1;
  bool lang :1;
  bool extMap :1;
  bool cur_lng :1;
  bool cur_lat :1;
  bool bubble_pid :1;
  bool bubble_trace_id :1;
  bool appversion :1;
  bool product_id :1;
  bool trace_info :1;
} _ForecastDepartureTimeRequest__isset;

class ForecastDepartureTimeRequest {
 public:

  static const char* ascii_fingerprint; // = "0A21427BD81FC65AA27CE2A7168F9724";
  static const uint8_t binary_fingerprint[16]; // = {0x0A,0x21,0x42,0x7B,0xD8,0x1F,0xC6,0x5A,0xA2,0x7C,0xE2,0xA7,0x16,0x8F,0x97,0x24};

  ForecastDepartureTimeRequest(const ForecastDepartureTimeRequest&);
  ForecastDepartureTimeRequest& operator=(const ForecastDepartureTimeRequest&);
  ForecastDepartureTimeRequest() : city_id(0), pid(), traceid(), spanid(), station_id(), last_ready_departure_time(0), lang(), cur_lng(0), cur_lat(0), bubble_pid(), bubble_trace_id(), appversion(), product_id() {
  }

  virtual ~ForecastDepartureTimeRequest() throw();
  int32_t city_id;
  std::string pid;
  std::string traceid;
  std::string spanid;
  std::string station_id;
  int64_t last_ready_departure_time;
  std::string lang;
  std::map<std::string, std::string>  extMap;
  double cur_lng;
  double cur_lat;
  std::string bubble_pid;
  std::string bubble_trace_id;
  std::string appversion;
  std::string product_id;
  Trace trace_info;

  _ForecastDepartureTimeRequest__isset __isset;

  void __set_city_id(const int32_t val);

  void __set_pid(const std::string& val);

  void __set_traceid(const std::string& val);

  void __set_spanid(const std::string& val);

  void __set_station_id(const std::string& val);

  void __set_last_ready_departure_time(const int64_t val);

  void __set_lang(const std::string& val);

  void __set_extMap(const std::map<std::string, std::string> & val);

  void __set_cur_lng(const double val);

  void __set_cur_lat(const double val);

  void __set_bubble_pid(const std::string& val);

  void __set_bubble_trace_id(const std::string& val);

  void __set_appversion(const std::string& val);

  void __set_product_id(const std::string& val);

  void __set_trace_info(const Trace& val);

  bool operator == (const ForecastDepartureTimeRequest & rhs) const
  {
    if (!(city_id == rhs.city_id))
      return false;
    if (!(pid == rhs.pid))
      return false;
    if (!(traceid == rhs.traceid))
      return false;
    if (!(spanid == rhs.spanid))
      return false;
    if (!(station_id == rhs.station_id))
      return false;
    if (__isset.last_ready_departure_time != rhs.__isset.last_ready_departure_time)
      return false;
    else if (__isset.last_ready_departure_time && !(last_ready_departure_time == rhs.last_ready_departure_time))
      return false;
    if (__isset.lang != rhs.__isset.lang)
      return false;
    else if (__isset.lang && !(lang == rhs.lang))
      return false;
    if (__isset.extMap != rhs.__isset.extMap)
      return false;
    else if (__isset.extMap && !(extMap == rhs.extMap))
      return false;
    if (__isset.cur_lng != rhs.__isset.cur_lng)
      return false;
    else if (__isset.cur_lng && !(cur_lng == rhs.cur_lng))
      return false;
    if (__isset.cur_lat != rhs.__isset.cur_lat)
      return false;
    else if (__isset.cur_lat && !(cur_lat == rhs.cur_lat))
      return false;
    if (__isset.bubble_pid != rhs.__isset.bubble_pid)
      return false;
    else if (__isset.bubble_pid && !(bubble_pid == rhs.bubble_pid))
      return false;
    if (__isset.bubble_trace_id != rhs.__isset.bubble_trace_id)
      return false;
    else if (__isset.bubble_trace_id && !(bubble_trace_id == rhs.bubble_trace_id))
      return false;
    if (__isset.appversion != rhs.__isset.appversion)
      return false;
    else if (__isset.appversion && !(appversion == rhs.appversion))
      return false;
    if (__isset.product_id != rhs.__isset.product_id)
      return false;
    else if (__isset.product_id && !(product_id == rhs.product_id))
      return false;
    if (__isset.trace_info != rhs.__isset.trace_info)
      return false;
    else if (__isset.trace_info && !(trace_info == rhs.trace_info))
      return false;
    return true;
  }
  bool operator != (const ForecastDepartureTimeRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ForecastDepartureTimeRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ForecastDepartureTimeRequest& obj);
};

void swap(ForecastDepartureTimeRequest &a, ForecastDepartureTimeRequest &b);

typedef struct _ForecastDepartureTimeResponse__isset {
  _ForecastDepartureTimeResponse__isset() : ready_departure_time(false), rec_status(false), time_type(false), left_time(false), right_time(false), left_show_time(false), right_show_time(false), hold_time(false) {}
  bool ready_departure_time :1;
  bool rec_status :1;
  bool time_type :1;
  bool left_time :1;
  bool right_time :1;
  bool left_show_time :1;
  bool right_show_time :1;
  bool hold_time :1;
} _ForecastDepartureTimeResponse__isset;

class ForecastDepartureTimeResponse {
 public:

  static const char* ascii_fingerprint; // = "43E9AF517D121FDAB432F0ECCC11D01D";
  static const uint8_t binary_fingerprint[16]; // = {0x43,0xE9,0xAF,0x51,0x7D,0x12,0x1F,0xDA,0xB4,0x32,0xF0,0xEC,0xCC,0x11,0xD0,0x1D};

  ForecastDepartureTimeResponse(const ForecastDepartureTimeResponse&);
  ForecastDepartureTimeResponse& operator=(const ForecastDepartureTimeResponse&);
  ForecastDepartureTimeResponse() : error_code(0), error_msg(), ready_departure_time(0), rec_status(0), time_type(0), left_time(0), right_time(0), left_show_time(0), right_show_time(0), hold_time(0) {
  }

  virtual ~ForecastDepartureTimeResponse() throw();
  int32_t error_code;
  std::string error_msg;
  int64_t ready_departure_time;
  int32_t rec_status;
  int32_t time_type;
  int64_t left_time;
  int64_t right_time;
  int32_t left_show_time;
  int32_t right_show_time;
  int32_t hold_time;

  _ForecastDepartureTimeResponse__isset __isset;

  void __set_error_code(const int32_t val);

  void __set_error_msg(const std::string& val);

  void __set_ready_departure_time(const int64_t val);

  void __set_rec_status(const int32_t val);

  void __set_time_type(const int32_t val);

  void __set_left_time(const int64_t val);

  void __set_right_time(const int64_t val);

  void __set_left_show_time(const int32_t val);

  void __set_right_show_time(const int32_t val);

  void __set_hold_time(const int32_t val);

  bool operator == (const ForecastDepartureTimeResponse & rhs) const
  {
    if (!(error_code == rhs.error_code))
      return false;
    if (!(error_msg == rhs.error_msg))
      return false;
    if (__isset.ready_departure_time != rhs.__isset.ready_departure_time)
      return false;
    else if (__isset.ready_departure_time && !(ready_departure_time == rhs.ready_departure_time))
      return false;
    if (__isset.rec_status != rhs.__isset.rec_status)
      return false;
    else if (__isset.rec_status && !(rec_status == rhs.rec_status))
      return false;
    if (__isset.time_type != rhs.__isset.time_type)
      return false;
    else if (__isset.time_type && !(time_type == rhs.time_type))
      return false;
    if (__isset.left_time != rhs.__isset.left_time)
      return false;
    else if (__isset.left_time && !(left_time == rhs.left_time))
      return false;
    if (__isset.right_time != rhs.__isset.right_time)
      return false;
    else if (__isset.right_time && !(right_time == rhs.right_time))
      return false;
    if (__isset.left_show_time != rhs.__isset.left_show_time)
      return false;
    else if (__isset.left_show_time && !(left_show_time == rhs.left_show_time))
      return false;
    if (__isset.right_show_time != rhs.__isset.right_show_time)
      return false;
    else if (__isset.right_show_time && !(right_show_time == rhs.right_show_time))
      return false;
    if (__isset.hold_time != rhs.__isset.hold_time)
      return false;
    else if (__isset.hold_time && !(hold_time == rhs.hold_time))
      return false;
    return true;
  }
  bool operator != (const ForecastDepartureTimeResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ForecastDepartureTimeResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ForecastDepartureTimeResponse& obj);
};

void swap(ForecastDepartureTimeResponse &a, ForecastDepartureTimeResponse &b);

typedef struct _MatchDetailRequest__isset {
  _MatchDetailRequest__isset() : order_id(false), appversion(false), extMap(false), traceid(false), trace_info(false) {}
  bool order_id :1;
  bool appversion :1;
  bool extMap :1;
  bool traceid :1;
  bool trace_info :1;
} _MatchDetailRequest__isset;

class MatchDetailRequest {
 public:

  static const char* ascii_fingerprint; // = "409417E6119667E559C50F4D18840BC3";
  static const uint8_t binary_fingerprint[16]; // = {0x40,0x94,0x17,0xE6,0x11,0x96,0x67,0xE5,0x59,0xC5,0x0F,0x4D,0x18,0x84,0x0B,0xC3};

  MatchDetailRequest(const MatchDetailRequest&);
  MatchDetailRequest& operator=(const MatchDetailRequest&);
  MatchDetailRequest() : bubble_trace_id(), city_id(), pid(), birth_time(0), order_id(0), appversion(), traceid() {
  }

  virtual ~MatchDetailRequest() throw();
  std::string bubble_trace_id;
  std::string city_id;
  std::string pid;
  int64_t birth_time;
  int64_t order_id;
  std::string appversion;
  std::map<std::string, std::string>  extMap;
  std::string traceid;
  Trace trace_info;

  _MatchDetailRequest__isset __isset;

  void __set_bubble_trace_id(const std::string& val);

  void __set_city_id(const std::string& val);

  void __set_pid(const std::string& val);

  void __set_birth_time(const int64_t val);

  void __set_order_id(const int64_t val);

  void __set_appversion(const std::string& val);

  void __set_extMap(const std::map<std::string, std::string> & val);

  void __set_traceid(const std::string& val);

  void __set_trace_info(const Trace& val);

  bool operator == (const MatchDetailRequest & rhs) const
  {
    if (!(bubble_trace_id == rhs.bubble_trace_id))
      return false;
    if (!(city_id == rhs.city_id))
      return false;
    if (!(pid == rhs.pid))
      return false;
    if (!(birth_time == rhs.birth_time))
      return false;
    if (__isset.order_id != rhs.__isset.order_id)
      return false;
    else if (__isset.order_id && !(order_id == rhs.order_id))
      return false;
    if (__isset.appversion != rhs.__isset.appversion)
      return false;
    else if (__isset.appversion && !(appversion == rhs.appversion))
      return false;
    if (__isset.extMap != rhs.__isset.extMap)
      return false;
    else if (__isset.extMap && !(extMap == rhs.extMap))
      return false;
    if (__isset.traceid != rhs.__isset.traceid)
      return false;
    else if (__isset.traceid && !(traceid == rhs.traceid))
      return false;
    if (__isset.trace_info != rhs.__isset.trace_info)
      return false;
    else if (__isset.trace_info && !(trace_info == rhs.trace_info))
      return false;
    return true;
  }
  bool operator != (const MatchDetailRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MatchDetailRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const MatchDetailRequest& obj);
};

void swap(MatchDetailRequest &a, MatchDetailRequest &b);


class MatchFeature {
 public:

  static const char* ascii_fingerprint; // = "EEBC915CE44901401D881E6091423036";
  static const uint8_t binary_fingerprint[16]; // = {0xEE,0xBC,0x91,0x5C,0xE4,0x49,0x01,0x40,0x1D,0x88,0x1E,0x60,0x91,0x42,0x30,0x36};

  MatchFeature(const MatchFeature&);
  MatchFeature& operator=(const MatchFeature&);
  MatchFeature() : pid(), match_degree(0) {
  }

  virtual ~MatchFeature() throw();
  std::string pid;
  int32_t match_degree;

  void __set_pid(const std::string& val);

  void __set_match_degree(const int32_t val);

  bool operator == (const MatchFeature & rhs) const
  {
    if (!(pid == rhs.pid))
      return false;
    if (!(match_degree == rhs.match_degree))
      return false;
    return true;
  }
  bool operator != (const MatchFeature &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MatchFeature & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const MatchFeature& obj);
};

void swap(MatchFeature &a, MatchFeature &b);

typedef struct _MatchDetailResponse__isset {
  _MatchDetailResponse__isset() : matchFeatureList(false), hold_time(false), elapsed_time(false), rec_status(false) {}
  bool matchFeatureList :1;
  bool hold_time :1;
  bool elapsed_time :1;
  bool rec_status :1;
} _MatchDetailResponse__isset;

class MatchDetailResponse {
 public:

  static const char* ascii_fingerprint; // = "49EA2206E6C12DF2AB0FE74871607CCD";
  static const uint8_t binary_fingerprint[16]; // = {0x49,0xEA,0x22,0x06,0xE6,0xC1,0x2D,0xF2,0xAB,0x0F,0xE7,0x48,0x71,0x60,0x7C,0xCD};

  MatchDetailResponse(const MatchDetailResponse&);
  MatchDetailResponse& operator=(const MatchDetailResponse&);
  MatchDetailResponse() : error_code(0), error_msg(), hold_time(0), elapsed_time(0), rec_status(0) {
  }

  virtual ~MatchDetailResponse() throw();
  int32_t error_code;
  std::string error_msg;
  std::vector<MatchFeature>  matchFeatureList;
  int32_t hold_time;
  int32_t elapsed_time;
  int32_t rec_status;

  _MatchDetailResponse__isset __isset;

  void __set_error_code(const int32_t val);

  void __set_error_msg(const std::string& val);

  void __set_matchFeatureList(const std::vector<MatchFeature> & val);

  void __set_hold_time(const int32_t val);

  void __set_elapsed_time(const int32_t val);

  void __set_rec_status(const int32_t val);

  bool operator == (const MatchDetailResponse & rhs) const
  {
    if (!(error_code == rhs.error_code))
      return false;
    if (!(error_msg == rhs.error_msg))
      return false;
    if (__isset.matchFeatureList != rhs.__isset.matchFeatureList)
      return false;
    else if (__isset.matchFeatureList && !(matchFeatureList == rhs.matchFeatureList))
      return false;
    if (__isset.hold_time != rhs.__isset.hold_time)
      return false;
    else if (__isset.hold_time && !(hold_time == rhs.hold_time))
      return false;
    if (__isset.elapsed_time != rhs.__isset.elapsed_time)
      return false;
    else if (__isset.elapsed_time && !(elapsed_time == rhs.elapsed_time))
      return false;
    if (__isset.rec_status != rhs.__isset.rec_status)
      return false;
    else if (__isset.rec_status && !(rec_status == rhs.rec_status))
      return false;
    return true;
  }
  bool operator != (const MatchDetailResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MatchDetailResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const MatchDetailResponse& obj);
};

void swap(MatchDetailResponse &a, MatchDetailResponse &b);

typedef struct _GetForecastFeatureRequest__isset {
  _GetForecastFeatureRequest__isset() : city_id(false), pid(false), phone(false), extMap(false), traceid(false), spanid(false), trace_info(false) {}
  bool city_id :1;
  bool pid :1;
  bool phone :1;
  bool extMap :1;
  bool traceid :1;
  bool spanid :1;
  bool trace_info :1;
} _GetForecastFeatureRequest__isset;

class GetForecastFeatureRequest {
 public:

  static const char* ascii_fingerprint; // = "81820A61B4B26B13A1B0AC8320716BB3";
  static const uint8_t binary_fingerprint[16]; // = {0x81,0x82,0x0A,0x61,0xB4,0xB2,0x6B,0x13,0xA1,0xB0,0xAC,0x83,0x20,0x71,0x6B,0xB3};

  GetForecastFeatureRequest(const GetForecastFeatureRequest&);
  GetForecastFeatureRequest& operator=(const GetForecastFeatureRequest&);
  GetForecastFeatureRequest() : bubble_trace_id(), city_id(0), pid(), phone(), traceid(), spanid() {
  }

  virtual ~GetForecastFeatureRequest() throw();
  std::string bubble_trace_id;
  int32_t city_id;
  std::string pid;
  std::string phone;
  std::map<std::string, std::string>  extMap;
  std::string traceid;
  std::string spanid;
  Trace trace_info;

  _GetForecastFeatureRequest__isset __isset;

  void __set_bubble_trace_id(const std::string& val);

  void __set_city_id(const int32_t val);

  void __set_pid(const std::string& val);

  void __set_phone(const std::string& val);

  void __set_extMap(const std::map<std::string, std::string> & val);

  void __set_traceid(const std::string& val);

  void __set_spanid(const std::string& val);

  void __set_trace_info(const Trace& val);

  bool operator == (const GetForecastFeatureRequest & rhs) const
  {
    if (!(bubble_trace_id == rhs.bubble_trace_id))
      return false;
    if (__isset.city_id != rhs.__isset.city_id)
      return false;
    else if (__isset.city_id && !(city_id == rhs.city_id))
      return false;
    if (__isset.pid != rhs.__isset.pid)
      return false;
    else if (__isset.pid && !(pid == rhs.pid))
      return false;
    if (__isset.phone != rhs.__isset.phone)
      return false;
    else if (__isset.phone && !(phone == rhs.phone))
      return false;
    if (__isset.extMap != rhs.__isset.extMap)
      return false;
    else if (__isset.extMap && !(extMap == rhs.extMap))
      return false;
    if (__isset.traceid != rhs.__isset.traceid)
      return false;
    else if (__isset.traceid && !(traceid == rhs.traceid))
      return false;
    if (__isset.spanid != rhs.__isset.spanid)
      return false;
    else if (__isset.spanid && !(spanid == rhs.spanid))
      return false;
    if (__isset.trace_info != rhs.__isset.trace_info)
      return false;
    else if (__isset.trace_info && !(trace_info == rhs.trace_info))
      return false;
    return true;
  }
  bool operator != (const GetForecastFeatureRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetForecastFeatureRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const GetForecastFeatureRequest& obj);
};

void swap(GetForecastFeatureRequest &a, GetForecastFeatureRequest &b);


class GetForecastFeatureResponse {
 public:

  static const char* ascii_fingerprint; // = "CF8E34C3B013B8FBCDA7987E6BC40786";
  static const uint8_t binary_fingerprint[16]; // = {0xCF,0x8E,0x34,0xC3,0xB0,0x13,0xB8,0xFB,0xCD,0xA7,0x98,0x7E,0x6B,0xC4,0x07,0x86};

  GetForecastFeatureResponse(const GetForecastFeatureResponse&);
  GetForecastFeatureResponse& operator=(const GetForecastFeatureResponse&);
  GetForecastFeatureResponse() : error_code(0), error_msg() {
  }

  virtual ~GetForecastFeatureResponse() throw();
  int32_t error_code;
  std::string error_msg;
  std::map<std::string, double>  forecastFeature;

  void __set_error_code(const int32_t val);

  void __set_error_msg(const std::string& val);

  void __set_forecastFeature(const std::map<std::string, double> & val);

  bool operator == (const GetForecastFeatureResponse & rhs) const
  {
    if (!(error_code == rhs.error_code))
      return false;
    if (!(error_msg == rhs.error_msg))
      return false;
    if (!(forecastFeature == rhs.forecastFeature))
      return false;
    return true;
  }
  bool operator != (const GetForecastFeatureResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetForecastFeatureResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const GetForecastFeatureResponse& obj);
};

void swap(GetForecastFeatureResponse &a, GetForecastFeatureResponse &b);

typedef struct _ProductType__isset {
  _ProductType__isset() : product_id(false), combo_type(false), require_level(false) {}
  bool product_id :1;
  bool combo_type :1;
  bool require_level :1;
} _ProductType__isset;

class ProductType {
 public:

  static const char* ascii_fingerprint; // = "D0B01547DD71CCE7ED280A08ECC7D976";
  static const uint8_t binary_fingerprint[16]; // = {0xD0,0xB0,0x15,0x47,0xDD,0x71,0xCC,0xE7,0xED,0x28,0x0A,0x08,0xEC,0xC7,0xD9,0x76};

  ProductType(const ProductType&);
  ProductType& operator=(const ProductType&);
  ProductType() : product_id(), combo_type(0), require_level() {
  }

  virtual ~ProductType() throw();
  std::string product_id;
  int16_t combo_type;
  std::string require_level;

  _ProductType__isset __isset;

  void __set_product_id(const std::string& val);

  void __set_combo_type(const int16_t val);

  void __set_require_level(const std::string& val);

  bool operator == (const ProductType & rhs) const
  {
    if (__isset.product_id != rhs.__isset.product_id)
      return false;
    else if (__isset.product_id && !(product_id == rhs.product_id))
      return false;
    if (__isset.combo_type != rhs.__isset.combo_type)
      return false;
    else if (__isset.combo_type && !(combo_type == rhs.combo_type))
      return false;
    if (__isset.require_level != rhs.__isset.require_level)
      return false;
    else if (__isset.require_level && !(require_level == rhs.require_level))
      return false;
    return true;
  }
  bool operator != (const ProductType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ProductType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ProductType& obj);
};

void swap(ProductType &a, ProductType &b);

typedef struct _PrematchhHoldInfoRequest__isset {
  _PrematchhHoldInfoRequest__isset() : extMap(false), productReq(false), trace_info(false) {}
  bool extMap :1;
  bool productReq :1;
  bool trace_info :1;
} _PrematchhHoldInfoRequest__isset;

class PrematchhHoldInfoRequest {
 public:

  static const char* ascii_fingerprint; // = "2AB0262763726E78564DFF21A1867B3E";
  static const uint8_t binary_fingerprint[16]; // = {0x2A,0xB0,0x26,0x27,0x63,0x72,0x6E,0x78,0x56,0x4D,0xFF,0x21,0xA1,0x86,0x7B,0x3E};

  PrematchhHoldInfoRequest(const PrematchhHoldInfoRequest&);
  PrematchhHoldInfoRequest& operator=(const PrematchhHoldInfoRequest&);
  PrematchhHoldInfoRequest() : phone(), pid(), city_id(0), cur_lng(0), cur_lat(0), start_lng(0), start_lat(0), start_name(), dest_lng(0), dest_lat(0), dest_name(), traceid() {
  }

  virtual ~PrematchhHoldInfoRequest() throw();
  std::string phone;
  std::string pid;
  int32_t city_id;
  double cur_lng;
  double cur_lat;
  double start_lng;
  double start_lat;
  std::string start_name;
  double dest_lng;
  double dest_lat;
  std::string dest_name;
  std::string traceid;
  std::map<std::string, std::string>  extMap;
  std::vector<ProductType>  productReq;
  Trace trace_info;

  _PrematchhHoldInfoRequest__isset __isset;

  void __set_phone(const std::string& val);

  void __set_pid(const std::string& val);

  void __set_city_id(const int32_t val);

  void __set_cur_lng(const double val);

  void __set_cur_lat(const double val);

  void __set_start_lng(const double val);

  void __set_start_lat(const double val);

  void __set_start_name(const std::string& val);

  void __set_dest_lng(const double val);

  void __set_dest_lat(const double val);

  void __set_dest_name(const std::string& val);

  void __set_traceid(const std::string& val);

  void __set_extMap(const std::map<std::string, std::string> & val);

  void __set_productReq(const std::vector<ProductType> & val);

  void __set_trace_info(const Trace& val);

  bool operator == (const PrematchhHoldInfoRequest & rhs) const
  {
    if (!(phone == rhs.phone))
      return false;
    if (!(pid == rhs.pid))
      return false;
    if (!(city_id == rhs.city_id))
      return false;
    if (!(cur_lng == rhs.cur_lng))
      return false;
    if (!(cur_lat == rhs.cur_lat))
      return false;
    if (!(start_lng == rhs.start_lng))
      return false;
    if (!(start_lat == rhs.start_lat))
      return false;
    if (!(start_name == rhs.start_name))
      return false;
    if (!(dest_lng == rhs.dest_lng))
      return false;
    if (!(dest_lat == rhs.dest_lat))
      return false;
    if (!(dest_name == rhs.dest_name))
      return false;
    if (!(traceid == rhs.traceid))
      return false;
    if (__isset.extMap != rhs.__isset.extMap)
      return false;
    else if (__isset.extMap && !(extMap == rhs.extMap))
      return false;
    if (__isset.productReq != rhs.__isset.productReq)
      return false;
    else if (__isset.productReq && !(productReq == rhs.productReq))
      return false;
    if (__isset.trace_info != rhs.__isset.trace_info)
      return false;
    else if (__isset.trace_info && !(trace_info == rhs.trace_info))
      return false;
    return true;
  }
  bool operator != (const PrematchhHoldInfoRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PrematchhHoldInfoRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const PrematchhHoldInfoRequest& obj);
};

void swap(PrematchhHoldInfoRequest &a, PrematchhHoldInfoRequest &b);

typedef struct _PrematchHoldRes__isset {
  _PrematchHoldRes__isset() : require_level(false), hold_time(false), hit_hold(false), hold_time_select(false), product_info(false) {}
  bool require_level :1;
  bool hold_time :1;
  bool hit_hold :1;
  bool hold_time_select :1;
  bool product_info :1;
} _PrematchHoldRes__isset;

class PrematchHoldRes {
 public:

  static const char* ascii_fingerprint; // = "461F16B34D7D3641D7570A1F391C6993";
  static const uint8_t binary_fingerprint[16]; // = {0x46,0x1F,0x16,0xB3,0x4D,0x7D,0x36,0x41,0xD7,0x57,0x0A,0x1F,0x39,0x1C,0x69,0x93};

  PrematchHoldRes(const PrematchHoldRes&);
  PrematchHoldRes& operator=(const PrematchHoldRes&);
  PrematchHoldRes() : error_code(0), error_msg(), require_level(), hold_time(0), hit_hold(0), hold_time_select(0) {
  }

  virtual ~PrematchHoldRes() throw();
  int32_t error_code;
  std::string error_msg;
  std::string require_level;
  int32_t hold_time;
  int32_t hit_hold;
  int32_t hold_time_select;
  ProductType product_info;

  _PrematchHoldRes__isset __isset;

  void __set_error_code(const int32_t val);

  void __set_error_msg(const std::string& val);

  void __set_require_level(const std::string& val);

  void __set_hold_time(const int32_t val);

  void __set_hit_hold(const int32_t val);

  void __set_hold_time_select(const int32_t val);

  void __set_product_info(const ProductType& val);

  bool operator == (const PrematchHoldRes & rhs) const
  {
    if (!(error_code == rhs.error_code))
      return false;
    if (!(error_msg == rhs.error_msg))
      return false;
    if (__isset.require_level != rhs.__isset.require_level)
      return false;
    else if (__isset.require_level && !(require_level == rhs.require_level))
      return false;
    if (__isset.hold_time != rhs.__isset.hold_time)
      return false;
    else if (__isset.hold_time && !(hold_time == rhs.hold_time))
      return false;
    if (__isset.hit_hold != rhs.__isset.hit_hold)
      return false;
    else if (__isset.hit_hold && !(hit_hold == rhs.hit_hold))
      return false;
    if (__isset.hold_time_select != rhs.__isset.hold_time_select)
      return false;
    else if (__isset.hold_time_select && !(hold_time_select == rhs.hold_time_select))
      return false;
    if (__isset.product_info != rhs.__isset.product_info)
      return false;
    else if (__isset.product_info && !(product_info == rhs.product_info))
      return false;
    return true;
  }
  bool operator != (const PrematchHoldRes &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PrematchHoldRes & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const PrematchHoldRes& obj);
};

void swap(PrematchHoldRes &a, PrematchHoldRes &b);

typedef struct _PrematchhHoldInfoResponse__isset {
  _PrematchhHoldInfoResponse__isset() : hold_time(false), hit_hold(false), hold_time_select(false), holdResults(false) {}
  bool hold_time :1;
  bool hit_hold :1;
  bool hold_time_select :1;
  bool holdResults :1;
} _PrematchhHoldInfoResponse__isset;

class PrematchhHoldInfoResponse {
 public:

  static const char* ascii_fingerprint; // = "80CE7C4CC30B155F3642BCB53BD22EDC";
  static const uint8_t binary_fingerprint[16]; // = {0x80,0xCE,0x7C,0x4C,0xC3,0x0B,0x15,0x5F,0x36,0x42,0xBC,0xB5,0x3B,0xD2,0x2E,0xDC};

  PrematchhHoldInfoResponse(const PrematchhHoldInfoResponse&);
  PrematchhHoldInfoResponse& operator=(const PrematchhHoldInfoResponse&);
  PrematchhHoldInfoResponse() : error_code(0), error_msg(), hold_time(0), hit_hold(0), hold_time_select(0) {
  }

  virtual ~PrematchhHoldInfoResponse() throw();
  int32_t error_code;
  std::string error_msg;
  int32_t hold_time;
  int32_t hit_hold;
  int32_t hold_time_select;
  std::vector<PrematchHoldRes>  holdResults;

  _PrematchhHoldInfoResponse__isset __isset;

  void __set_error_code(const int32_t val);

  void __set_error_msg(const std::string& val);

  void __set_hold_time(const int32_t val);

  void __set_hit_hold(const int32_t val);

  void __set_hold_time_select(const int32_t val);

  void __set_holdResults(const std::vector<PrematchHoldRes> & val);

  bool operator == (const PrematchhHoldInfoResponse & rhs) const
  {
    if (!(error_code == rhs.error_code))
      return false;
    if (!(error_msg == rhs.error_msg))
      return false;
    if (__isset.hold_time != rhs.__isset.hold_time)
      return false;
    else if (__isset.hold_time && !(hold_time == rhs.hold_time))
      return false;
    if (__isset.hit_hold != rhs.__isset.hit_hold)
      return false;
    else if (__isset.hit_hold && !(hit_hold == rhs.hit_hold))
      return false;
    if (__isset.hold_time_select != rhs.__isset.hold_time_select)
      return false;
    else if (__isset.hold_time_select && !(hold_time_select == rhs.hold_time_select))
      return false;
    if (__isset.holdResults != rhs.__isset.holdResults)
      return false;
    else if (__isset.holdResults && !(holdResults == rhs.holdResults))
      return false;
    return true;
  }
  bool operator != (const PrematchhHoldInfoResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PrematchhHoldInfoResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const PrematchhHoldInfoResponse& obj);
};

void swap(PrematchhHoldInfoResponse &a, PrematchhHoldInfoResponse &b);

typedef struct _PrematchStationRes__isset {
  _PrematchStationRes__isset() : extMap(false) {}
  bool extMap :1;
} _PrematchStationRes__isset;

class PrematchStationRes {
 public:

  static const char* ascii_fingerprint; // = "C8940ABA1BA90F63E2081F6155F3561F";
  static const uint8_t binary_fingerprint[16]; // = {0xC8,0x94,0x0A,0xBA,0x1B,0xA9,0x0F,0x63,0xE2,0x08,0x1F,0x61,0x55,0xF3,0x56,0x1F};

  PrematchStationRes(const PrematchStationRes&);
  PrematchStationRes& operator=(const PrematchStationRes&);
  PrematchStationRes() : error_code(0), error_msg() {
  }

  virtual ~PrematchStationRes() throw();
  int32_t error_code;
  std::string error_msg;
  ProductType product_info;
  std::vector<StationInfo>  station_list;
  std::map<std::string, std::string>  extMap;

  _PrematchStationRes__isset __isset;

  void __set_error_code(const int32_t val);

  void __set_error_msg(const std::string& val);

  void __set_product_info(const ProductType& val);

  void __set_station_list(const std::vector<StationInfo> & val);

  void __set_extMap(const std::map<std::string, std::string> & val);

  bool operator == (const PrematchStationRes & rhs) const
  {
    if (!(error_code == rhs.error_code))
      return false;
    if (!(error_msg == rhs.error_msg))
      return false;
    if (!(product_info == rhs.product_info))
      return false;
    if (!(station_list == rhs.station_list))
      return false;
    if (__isset.extMap != rhs.__isset.extMap)
      return false;
    else if (__isset.extMap && !(extMap == rhs.extMap))
      return false;
    return true;
  }
  bool operator != (const PrematchStationRes &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PrematchStationRes & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const PrematchStationRes& obj);
};

void swap(PrematchStationRes &a, PrematchStationRes &b);

typedef struct _PrematchEtdRes__isset {
  _PrematchEtdRes__isset() : extMap(false) {}
  bool extMap :1;
} _PrematchEtdRes__isset;

class PrematchEtdRes {
 public:

  static const char* ascii_fingerprint; // = "A467D19E8DDF71D3CBBF4E7844FF520C";
  static const uint8_t binary_fingerprint[16]; // = {0xA4,0x67,0xD1,0x9E,0x8D,0xDF,0x71,0xD3,0xCB,0xBF,0x4E,0x78,0x44,0xFF,0x52,0x0C};

  PrematchEtdRes(const PrematchEtdRes&);
  PrematchEtdRes& operator=(const PrematchEtdRes&);
  PrematchEtdRes() : error_code(0), error_msg() {
  }

  virtual ~PrematchEtdRes() throw();
  int32_t error_code;
  std::string error_msg;
  ProductType product_info;
  CarpoolEtdInfo etd_info;
  std::map<std::string, std::string>  extMap;

  _PrematchEtdRes__isset __isset;

  void __set_error_code(const int32_t val);

  void __set_error_msg(const std::string& val);

  void __set_product_info(const ProductType& val);

  void __set_etd_info(const CarpoolEtdInfo& val);

  void __set_extMap(const std::map<std::string, std::string> & val);

  bool operator == (const PrematchEtdRes & rhs) const
  {
    if (!(error_code == rhs.error_code))
      return false;
    if (!(error_msg == rhs.error_msg))
      return false;
    if (!(product_info == rhs.product_info))
      return false;
    if (!(etd_info == rhs.etd_info))
      return false;
    if (__isset.extMap != rhs.__isset.extMap)
      return false;
    else if (__isset.extMap && !(extMap == rhs.extMap))
      return false;
    return true;
  }
  bool operator != (const PrematchEtdRes &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PrematchEtdRes & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const PrematchEtdRes& obj);
};

void swap(PrematchEtdRes &a, PrematchEtdRes &b);

typedef struct _PrematchRecommendRequest__isset {
  _PrematchRecommendRequest__isset() : extMap(false), productReq(false), trace_info(false) {}
  bool extMap :1;
  bool productReq :1;
  bool trace_info :1;
} _PrematchRecommendRequest__isset;

class PrematchRecommendRequest {
 public:

  static const char* ascii_fingerprint; // = "2AB0262763726E78564DFF21A1867B3E";
  static const uint8_t binary_fingerprint[16]; // = {0x2A,0xB0,0x26,0x27,0x63,0x72,0x6E,0x78,0x56,0x4D,0xFF,0x21,0xA1,0x86,0x7B,0x3E};

  PrematchRecommendRequest(const PrematchRecommendRequest&);
  PrematchRecommendRequest& operator=(const PrematchRecommendRequest&);
  PrematchRecommendRequest() : phone(), pid(), city_id(0), cur_lng(0), cur_lat(0), start_lng(0), start_lat(0), start_name(), dest_lng(0), dest_lat(0), dest_name(), traceid() {
  }

  virtual ~PrematchRecommendRequest() throw();
  std::string phone;
  std::string pid;
  int32_t city_id;
  double cur_lng;
  double cur_lat;
  double start_lng;
  double start_lat;
  std::string start_name;
  double dest_lng;
  double dest_lat;
  std::string dest_name;
  std::string traceid;
  std::map<std::string, std::string>  extMap;
  std::vector<ProductType>  productReq;
  Trace trace_info;

  _PrematchRecommendRequest__isset __isset;

  void __set_phone(const std::string& val);

  void __set_pid(const std::string& val);

  void __set_city_id(const int32_t val);

  void __set_cur_lng(const double val);

  void __set_cur_lat(const double val);

  void __set_start_lng(const double val);

  void __set_start_lat(const double val);

  void __set_start_name(const std::string& val);

  void __set_dest_lng(const double val);

  void __set_dest_lat(const double val);

  void __set_dest_name(const std::string& val);

  void __set_traceid(const std::string& val);

  void __set_extMap(const std::map<std::string, std::string> & val);

  void __set_productReq(const std::vector<ProductType> & val);

  void __set_trace_info(const Trace& val);

  bool operator == (const PrematchRecommendRequest & rhs) const
  {
    if (!(phone == rhs.phone))
      return false;
    if (!(pid == rhs.pid))
      return false;
    if (!(city_id == rhs.city_id))
      return false;
    if (!(cur_lng == rhs.cur_lng))
      return false;
    if (!(cur_lat == rhs.cur_lat))
      return false;
    if (!(start_lng == rhs.start_lng))
      return false;
    if (!(start_lat == rhs.start_lat))
      return false;
    if (!(start_name == rhs.start_name))
      return false;
    if (!(dest_lng == rhs.dest_lng))
      return false;
    if (!(dest_lat == rhs.dest_lat))
      return false;
    if (!(dest_name == rhs.dest_name))
      return false;
    if (!(traceid == rhs.traceid))
      return false;
    if (__isset.extMap != rhs.__isset.extMap)
      return false;
    else if (__isset.extMap && !(extMap == rhs.extMap))
      return false;
    if (__isset.productReq != rhs.__isset.productReq)
      return false;
    else if (__isset.productReq && !(productReq == rhs.productReq))
      return false;
    if (__isset.trace_info != rhs.__isset.trace_info)
      return false;
    else if (__isset.trace_info && !(trace_info == rhs.trace_info))
      return false;
    return true;
  }
  bool operator != (const PrematchRecommendRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PrematchRecommendRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const PrematchRecommendRequest& obj);
};

void swap(PrematchRecommendRequest &a, PrematchRecommendRequest &b);

typedef struct _PrematchRecommendResponse__isset {
  _PrematchRecommendResponse__isset() : holdResults(false), stationResults(false), etdResults(false), extMap(false) {}
  bool holdResults :1;
  bool stationResults :1;
  bool etdResults :1;
  bool extMap :1;
} _PrematchRecommendResponse__isset;

class PrematchRecommendResponse {
 public:

  static const char* ascii_fingerprint; // = "D6B8A30B56E8AE1F327543EE52DE027A";
  static const uint8_t binary_fingerprint[16]; // = {0xD6,0xB8,0xA3,0x0B,0x56,0xE8,0xAE,0x1F,0x32,0x75,0x43,0xEE,0x52,0xDE,0x02,0x7A};

  PrematchRecommendResponse(const PrematchRecommendResponse&);
  PrematchRecommendResponse& operator=(const PrematchRecommendResponse&);
  PrematchRecommendResponse() : error_code(0), error_msg() {
  }

  virtual ~PrematchRecommendResponse() throw();
  int32_t error_code;
  std::string error_msg;
  std::vector<PrematchHoldRes>  holdResults;
  std::vector<PrematchStationRes>  stationResults;
  std::vector<PrematchEtdRes>  etdResults;
  std::map<std::string, std::string>  extMap;

  _PrematchRecommendResponse__isset __isset;

  void __set_error_code(const int32_t val);

  void __set_error_msg(const std::string& val);

  void __set_holdResults(const std::vector<PrematchHoldRes> & val);

  void __set_stationResults(const std::vector<PrematchStationRes> & val);

  void __set_etdResults(const std::vector<PrematchEtdRes> & val);

  void __set_extMap(const std::map<std::string, std::string> & val);

  bool operator == (const PrematchRecommendResponse & rhs) const
  {
    if (!(error_code == rhs.error_code))
      return false;
    if (!(error_msg == rhs.error_msg))
      return false;
    if (__isset.holdResults != rhs.__isset.holdResults)
      return false;
    else if (__isset.holdResults && !(holdResults == rhs.holdResults))
      return false;
    if (__isset.stationResults != rhs.__isset.stationResults)
      return false;
    else if (__isset.stationResults && !(stationResults == rhs.stationResults))
      return false;
    if (__isset.etdResults != rhs.__isset.etdResults)
      return false;
    else if (__isset.etdResults && !(etdResults == rhs.etdResults))
      return false;
    if (__isset.extMap != rhs.__isset.extMap)
      return false;
    else if (__isset.extMap && !(extMap == rhs.extMap))
      return false;
    return true;
  }
  bool operator != (const PrematchRecommendResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PrematchRecommendResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const PrematchRecommendResponse& obj);
};

void swap(PrematchRecommendResponse &a, PrematchRecommendResponse &b);

typedef struct _CarpoolEtdRequest__isset {
  _CarpoolEtdRequest__isset() : ext_info(false) {}
  bool ext_info :1;
} _CarpoolEtdRequest__isset;

class CarpoolEtdRequest {
 public:

  static const char* ascii_fingerprint; // = "9A3A2EB7C3426EC5BD0FC4177912541D";
  static const uint8_t binary_fingerprint[16]; // = {0x9A,0x3A,0x2E,0xB7,0xC3,0x42,0x6E,0xC5,0xBD,0x0F,0xC4,0x17,0x79,0x12,0x54,0x1D};

  CarpoolEtdRequest(const CarpoolEtdRequest&);
  CarpoolEtdRequest& operator=(const CarpoolEtdRequest&);
  CarpoolEtdRequest() : bubble_id(), express_etd(0), city_id(0), phone(), pid() {
  }

  virtual ~CarpoolEtdRequest() throw();
  Trace trace_info;
  std::string bubble_id;
  int64_t express_etd;
  int32_t city_id;
  std::string phone;
  std::string pid;
  std::map<std::string, std::string>  ext_info;

  _CarpoolEtdRequest__isset __isset;

  void __set_trace_info(const Trace& val);

  void __set_bubble_id(const std::string& val);

  void __set_express_etd(const int64_t val);

  void __set_city_id(const int32_t val);

  void __set_phone(const std::string& val);

  void __set_pid(const std::string& val);

  void __set_ext_info(const std::map<std::string, std::string> & val);

  bool operator == (const CarpoolEtdRequest & rhs) const
  {
    if (!(trace_info == rhs.trace_info))
      return false;
    if (!(bubble_id == rhs.bubble_id))
      return false;
    if (!(express_etd == rhs.express_etd))
      return false;
    if (!(city_id == rhs.city_id))
      return false;
    if (!(phone == rhs.phone))
      return false;
    if (!(pid == rhs.pid))
      return false;
    if (__isset.ext_info != rhs.__isset.ext_info)
      return false;
    else if (__isset.ext_info && !(ext_info == rhs.ext_info))
      return false;
    return true;
  }
  bool operator != (const CarpoolEtdRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CarpoolEtdRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const CarpoolEtdRequest& obj);
};

void swap(CarpoolEtdRequest &a, CarpoolEtdRequest &b);

typedef struct _CarpoolEtdResponse__isset {
  _CarpoolEtdResponse__isset() : ext_info(false) {}
  bool ext_info :1;
} _CarpoolEtdResponse__isset;

class CarpoolEtdResponse {
 public:

  static const char* ascii_fingerprint; // = "047202887E904B4368A0B4D880793D94";
  static const uint8_t binary_fingerprint[16]; // = {0x04,0x72,0x02,0x88,0x7E,0x90,0x4B,0x43,0x68,0xA0,0xB4,0xD8,0x80,0x79,0x3D,0x94};

  CarpoolEtdResponse(const CarpoolEtdResponse&);
  CarpoolEtdResponse& operator=(const CarpoolEtdResponse&);
  CarpoolEtdResponse() : error_code(0), error_msg() {
  }

  virtual ~CarpoolEtdResponse() throw();
  int32_t error_code;
  std::string error_msg;
  CarpoolEtdInfo carpool_etd;
  std::map<std::string, std::string>  ext_info;

  _CarpoolEtdResponse__isset __isset;

  void __set_error_code(const int32_t val);

  void __set_error_msg(const std::string& val);

  void __set_carpool_etd(const CarpoolEtdInfo& val);

  void __set_ext_info(const std::map<std::string, std::string> & val);

  bool operator == (const CarpoolEtdResponse & rhs) const
  {
    if (!(error_code == rhs.error_code))
      return false;
    if (!(error_msg == rhs.error_msg))
      return false;
    if (!(carpool_etd == rhs.carpool_etd))
      return false;
    if (__isset.ext_info != rhs.__isset.ext_info)
      return false;
    else if (__isset.ext_info && !(ext_info == rhs.ext_info))
      return false;
    return true;
  }
  bool operator != (const CarpoolEtdResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CarpoolEtdResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const CarpoolEtdResponse& obj);
};

void swap(CarpoolEtdResponse &a, CarpoolEtdResponse &b);

}} // namespace

#endif
