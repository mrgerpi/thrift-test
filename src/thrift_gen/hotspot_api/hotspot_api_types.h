/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef hotspot_api_TYPES_H
#define hotspot_api_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace hotspot { namespace service {

struct TextType {
  enum type {
    EMPTY = 0,
    COMMON = 1,
    SPACIAL = 2
  };
};

extern const std::map<int, const char*> _TextType_VALUES_TO_NAMES;

class Trace;

class StationInfo;

class HotspotRequest;

class CarpoolEtdInfo;

class HotspotResponse;

class ForecastDepartureTimeRequest;

class ForecastDepartureTimeResponse;

class MatchDetailRequest;

class MatchFeature;

class MatchDetailResponse;

class GetForecastFeatureRequest;

class GetForecastFeatureResponse;

class ProductType;

class PrematchhHoldInfoRequest;

class PrematchHoldRes;

class PrematchhHoldInfoResponse;

class PrematchStationRes;

class PrematchEtdRes;

class PrematchRecommendRequest;

class PrematchRecommendResponse;

class CarpoolEtdRequest;

class CarpoolEtdResponse;


class Trace {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  Trace(const Trace&);
  Trace& operator=(const Trace&);
  Trace() : logId() {
  }

  virtual ~Trace() throw();
  std::string logId;

  void __set_logId(const std::string& val);

  bool operator == (const Trace & rhs) const
  {
    if (!(logId == rhs.logId))
      return false;
    return true;
  }
  bool operator != (const Trace &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Trace & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Trace& obj);
};

void swap(Trace &a, Trace &b);


class StationInfo {
 public:

  static const char* ascii_fingerprint; // = "D8824F455AAD39A35933B60845B3BC95";
  static const uint8_t binary_fingerprint[16]; // = {0xD8,0x82,0x4F,0x45,0x5A,0xAD,0x39,0xA3,0x59,0x33,0xB6,0x08,0x45,0xB3,0xBC,0x95};

  StationInfo(const StationInfo&);
  StationInfo& operator=(const StationInfo&);
  StationInfo() : lng(0) {
  }

  virtual ~StationInfo() throw();
  double lng;
  std::vector<int32_t>  nlist;
  std::set<int32_t>  nset;
  std::map<int32_t, std::string>  nmap;

  void __set_lng(const double val);

  void __set_nlist(const std::vector<int32_t> & val);

  void __set_nset(const std::set<int32_t> & val);

  void __set_nmap(const std::map<int32_t, std::string> & val);

  bool operator == (const StationInfo & rhs) const
  {
    if (!(lng == rhs.lng))
      return false;
    if (!(nlist == rhs.nlist))
      return false;
    if (!(nset == rhs.nset))
      return false;
    if (!(nmap == rhs.nmap))
      return false;
    return true;
  }
  bool operator != (const StationInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StationInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const StationInfo& obj);
};

void swap(StationInfo &a, StationInfo &b);


class HotspotRequest {
 public:

  static const char* ascii_fingerprint; // = "B14C578B6908BF84AAD1E2255E52C720";
  static const uint8_t binary_fingerprint[16]; // = {0xB1,0x4C,0x57,0x8B,0x69,0x08,0xBF,0x84,0xAA,0xD1,0xE2,0x25,0x5E,0x52,0xC7,0x20};

  HotspotRequest(const HotspotRequest&);
  HotspotRequest& operator=(const HotspotRequest&);
  HotspotRequest() : id(0), isTrue(0), product_id() {
  }

  virtual ~HotspotRequest() throw();
  int64_t id;
  bool isTrue;
  std::string product_id;
  StationInfo sinfo;

  void __set_id(const int64_t val);

  void __set_isTrue(const bool val);

  void __set_product_id(const std::string& val);

  void __set_sinfo(const StationInfo& val);

  bool operator == (const HotspotRequest & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(isTrue == rhs.isTrue))
      return false;
    if (!(product_id == rhs.product_id))
      return false;
    if (!(sinfo == rhs.sinfo))
      return false;
    return true;
  }
  bool operator != (const HotspotRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HotspotRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const HotspotRequest& obj);
};

void swap(HotspotRequest &a, HotspotRequest &b);


class CarpoolEtdInfo {
 public:

  static const char* ascii_fingerprint; // = "F33135321253DAEB67B0E79E416CA831";
  static const uint8_t binary_fingerprint[16]; // = {0xF3,0x31,0x35,0x32,0x12,0x53,0xDA,0xEB,0x67,0xB0,0xE7,0x9E,0x41,0x6C,0xA8,0x31};

  CarpoolEtdInfo(const CarpoolEtdInfo&);
  CarpoolEtdInfo& operator=(const CarpoolEtdInfo&);
  CarpoolEtdInfo() : etdLeftMargin(0), etdRightMargin(0) {
  }

  virtual ~CarpoolEtdInfo() throw();
  int64_t etdLeftMargin;
  int64_t etdRightMargin;

  void __set_etdLeftMargin(const int64_t val);

  void __set_etdRightMargin(const int64_t val);

  bool operator == (const CarpoolEtdInfo & rhs) const
  {
    if (!(etdLeftMargin == rhs.etdLeftMargin))
      return false;
    if (!(etdRightMargin == rhs.etdRightMargin))
      return false;
    return true;
  }
  bool operator != (const CarpoolEtdInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CarpoolEtdInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const CarpoolEtdInfo& obj);
};

void swap(CarpoolEtdInfo &a, CarpoolEtdInfo &b);

typedef struct _HotspotResponse__isset {
  _HotspotResponse__isset() : extends_info(false) {}
  bool extends_info :1;
} _HotspotResponse__isset;

class HotspotResponse {
 public:

  static const char* ascii_fingerprint; // = "5531C8D7ED2A5FC0358A03FFBCC21464";
  static const uint8_t binary_fingerprint[16]; // = {0x55,0x31,0xC8,0xD7,0xED,0x2A,0x5F,0xC0,0x35,0x8A,0x03,0xFF,0xBC,0xC2,0x14,0x64};

  HotspotResponse(const HotspotResponse&);
  HotspotResponse& operator=(const HotspotResponse&);
  HotspotResponse() : error_code(0), error_msg(), extends_info() {
  }

  virtual ~HotspotResponse() throw();
  int32_t error_code;
  std::string error_msg;
  std::string extends_info;

  _HotspotResponse__isset __isset;

  void __set_error_code(const int32_t val);

  void __set_error_msg(const std::string& val);

  void __set_extends_info(const std::string& val);

  bool operator == (const HotspotResponse & rhs) const
  {
    if (!(error_code == rhs.error_code))
      return false;
    if (!(error_msg == rhs.error_msg))
      return false;
    if (__isset.extends_info != rhs.__isset.extends_info)
      return false;
    else if (__isset.extends_info && !(extends_info == rhs.extends_info))
      return false;
    return true;
  }
  bool operator != (const HotspotResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HotspotResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const HotspotResponse& obj);
};

void swap(HotspotResponse &a, HotspotResponse &b);

typedef struct _ForecastDepartureTimeRequest__isset {
  _ForecastDepartureTimeRequest__isset() : last_ready_departure_time(false), lang(false), extMap(false), cur_lng(false), cur_lat(false), bubble_pid(false), bubble_trace_id(false), appversion(false), product_id(false), trace_info(false) {}
  bool last_ready_departure_time :1;
  bool lang :1;
  bool extMap :1;
  bool cur_lng :1;
  bool cur_lat :1;
  bool bubble_pid :1;
  bool bubble_trace_id :1;
  bool appversion :1;
  bool product_id :1;
  bool trace_info :1;
} _ForecastDepartureTimeRequest__isset;

class ForecastDepartureTimeRequest {
 public:

  static const char* ascii_fingerprint; // = "42C9AD9C724AC502EE4B8EF5B4153673";
  static const uint8_t binary_fingerprint[16]; // = {0x42,0xC9,0xAD,0x9C,0x72,0x4A,0xC5,0x02,0xEE,0x4B,0x8E,0xF5,0xB4,0x15,0x36,0x73};

  ForecastDepartureTimeRequest(const ForecastDepartureTimeRequest&);
  ForecastDepartureTimeRequest& operator=(const ForecastDepartureTimeRequest&);
  ForecastDepartureTimeRequest() : city_id(0), pid(), traceid(), spanid(), station_id(), last_ready_departure_time(0), lang(), cur_lng(0), cur_lat(0), bubble_pid(), bubble_trace_id(), appversion(), product_id() {
  }

  virtual ~ForecastDepartureTimeRequest() throw();
  int32_t city_id;
  std::string pid;
  std::string traceid;
  std::string spanid;
  std::string station_id;
  int64_t last_ready_departure_time;
  std::string lang;
  std::map<std::string, std::string>  extMap;
  double cur_lng;
  double cur_lat;
  std::string bubble_pid;
  std::string bubble_trace_id;
  std::string appversion;
  std::string product_id;
  Trace trace_info;

  _ForecastDepartureTimeRequest__isset __isset;

  void __set_city_id(const int32_t val);

  void __set_pid(const std::string& val);

  void __set_traceid(const std::string& val);

  void __set_spanid(const std::string& val);

  void __set_station_id(const std::string& val);

  void __set_last_ready_departure_time(const int64_t val);

  void __set_lang(const std::string& val);

  void __set_extMap(const std::map<std::string, std::string> & val);

  void __set_cur_lng(const double val);

  void __set_cur_lat(const double val);

  void __set_bubble_pid(const std::string& val);

  void __set_bubble_trace_id(const std::string& val);

  void __set_appversion(const std::string& val);

  void __set_product_id(const std::string& val);

  void __set_trace_info(const Trace& val);

  bool operator == (const ForecastDepartureTimeRequest & rhs) const
  {
    if (!(city_id == rhs.city_id))
      return false;
    if (!(pid == rhs.pid))
      return false;
    if (!(traceid == rhs.traceid))
      return false;
    if (!(spanid == rhs.spanid))
      return false;
    if (!(station_id == rhs.station_id))
      return false;
    if (__isset.last_ready_departure_time != rhs.__isset.last_ready_departure_time)
      return false;
    else if (__isset.last_ready_departure_time && !(last_ready_departure_time == rhs.last_ready_departure_time))
      return false;
    if (__isset.lang != rhs.__isset.lang)
      return false;
    else if (__isset.lang && !(lang == rhs.lang))
      return false;
    if (__isset.extMap != rhs.__isset.extMap)
      return false;
    else if (__isset.extMap && !(extMap == rhs.extMap))
      return false;
    if (__isset.cur_lng != rhs.__isset.cur_lng)
      return false;
    else if (__isset.cur_lng && !(cur_lng == rhs.cur_lng))
      return false;
    if (__isset.cur_lat != rhs.__isset.cur_lat)
      return false;
    else if (__isset.cur_lat && !(cur_lat == rhs.cur_lat))
      return false;
    if (__isset.bubble_pid != rhs.__isset.bubble_pid)
      return false;
    else if (__isset.bubble_pid && !(bubble_pid == rhs.bubble_pid))
      return false;
    if (__isset.bubble_trace_id != rhs.__isset.bubble_trace_id)
      return false;
    else if (__isset.bubble_trace_id && !(bubble_trace_id == rhs.bubble_trace_id))
      return false;
    if (__isset.appversion != rhs.__isset.appversion)
      return false;
    else if (__isset.appversion && !(appversion == rhs.appversion))
      return false;
    if (__isset.product_id != rhs.__isset.product_id)
      return false;
    else if (__isset.product_id && !(product_id == rhs.product_id))
      return false;
    if (__isset.trace_info != rhs.__isset.trace_info)
      return false;
    else if (__isset.trace_info && !(trace_info == rhs.trace_info))
      return false;
    return true;
  }
  bool operator != (const ForecastDepartureTimeRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ForecastDepartureTimeRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ForecastDepartureTimeRequest& obj);
};

void swap(ForecastDepartureTimeRequest &a, ForecastDepartureTimeRequest &b);

typedef struct _ForecastDepartureTimeResponse__isset {
  _ForecastDepartureTimeResponse__isset() : ready_departure_time(false), rec_status(false), time_type(false), left_time(false), right_time(false), left_show_time(false), right_show_time(false), hold_time(false) {}
  bool ready_departure_time :1;
  bool rec_status :1;
  bool time_type :1;
  bool left_time :1;
  bool right_time :1;
  bool left_show_time :1;
  bool right_show_time :1;
  bool hold_time :1;
} _ForecastDepartureTimeResponse__isset;

class ForecastDepartureTimeResponse {
 public:

  static const char* ascii_fingerprint; // = "43E9AF517D121FDAB432F0ECCC11D01D";
  static const uint8_t binary_fingerprint[16]; // = {0x43,0xE9,0xAF,0x51,0x7D,0x12,0x1F,0xDA,0xB4,0x32,0xF0,0xEC,0xCC,0x11,0xD0,0x1D};

  ForecastDepartureTimeResponse(const ForecastDepartureTimeResponse&);
  ForecastDepartureTimeResponse& operator=(const ForecastDepartureTimeResponse&);
  ForecastDepartureTimeResponse() : error_code(0), error_msg(), ready_departure_time(0), rec_status(0), time_type(0), left_time(0), right_time(0), left_show_time(0), right_show_time(0), hold_time(0) {
  }

  virtual ~ForecastDepartureTimeResponse() throw();
  int32_t error_code;
  std::string error_msg;
  int64_t ready_departure_time;
  int32_t rec_status;
  int32_t time_type;
  int64_t left_time;
  int64_t right_time;
  int32_t left_show_time;
  int32_t right_show_time;
  int32_t hold_time;

  _ForecastDepartureTimeResponse__isset __isset;

  void __set_error_code(const int32_t val);

  void __set_error_msg(const std::string& val);

  void __set_ready_departure_time(const int64_t val);

  void __set_rec_status(const int32_t val);

  void __set_time_type(const int32_t val);

  void __set_left_time(const int64_t val);

  void __set_right_time(const int64_t val);

  void __set_left_show_time(const int32_t val);

  void __set_right_show_time(const int32_t val);

  void __set_hold_time(const int32_t val);

  bool operator == (const ForecastDepartureTimeResponse & rhs) const
  {
    if (!(error_code == rhs.error_code))
      return false;
    if (!(error_msg == rhs.error_msg))
      return false;
    if (__isset.ready_departure_time != rhs.__isset.ready_departure_time)
      return false;
    else if (__isset.ready_departure_time && !(ready_departure_time == rhs.ready_departure_time))
      return false;
    if (__isset.rec_status != rhs.__isset.rec_status)
      return false;
    else if (__isset.rec_status && !(rec_status == rhs.rec_status))
      return false;
    if (__isset.time_type != rhs.__isset.time_type)
      return false;
    else if (__isset.time_type && !(time_type == rhs.time_type))
      return false;
    if (__isset.left_time != rhs.__isset.left_time)
      return false;
    else if (__isset.left_time && !(left_time == rhs.left_time))
      return false;
    if (__isset.right_time != rhs.__isset.right_time)
      return false;
    else if (__isset.right_time && !(right_time == rhs.right_time))
      return false;
    if (__isset.left_show_time != rhs.__isset.left_show_time)
      return false;
    else if (__isset.left_show_time && !(left_show_time == rhs.left_show_time))
      return false;
    if (__isset.right_show_time != rhs.__isset.right_show_time)
      return false;
    else if (__isset.right_show_time && !(right_show_time == rhs.right_show_time))
      return false;
    if (__isset.hold_time != rhs.__isset.hold_time)
      return false;
    else if (__isset.hold_time && !(hold_time == rhs.hold_time))
      return false;
    return true;
  }
  bool operator != (const ForecastDepartureTimeResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ForecastDepartureTimeResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ForecastDepartureTimeResponse& obj);
};

void swap(ForecastDepartureTimeResponse &a, ForecastDepartureTimeResponse &b);

typedef struct _MatchDetailRequest__isset {
  _MatchDetailRequest__isset() : order_id(false), appversion(false), extMap(false), traceid(false), trace_info(false) {}
  bool order_id :1;
  bool appversion :1;
  bool extMap :1;
  bool traceid :1;
  bool trace_info :1;
} _MatchDetailRequest__isset;

class MatchDetailRequest {
 public:

  static const char* ascii_fingerprint; // = "0A2EF6DA4787B4E52D25AD175457F49C";
  static const uint8_t binary_fingerprint[16]; // = {0x0A,0x2E,0xF6,0xDA,0x47,0x87,0xB4,0xE5,0x2D,0x25,0xAD,0x17,0x54,0x57,0xF4,0x9C};

  MatchDetailRequest(const MatchDetailRequest&);
  MatchDetailRequest& operator=(const MatchDetailRequest&);
  MatchDetailRequest() : bubble_trace_id(), city_id(), pid(), birth_time(0), order_id(0), appversion(), traceid() {
  }

  virtual ~MatchDetailRequest() throw();
  std::string bubble_trace_id;
  std::string city_id;
  std::string pid;
  int64_t birth_time;
  int64_t order_id;
  std::string appversion;
  std::map<std::string, std::string>  extMap;
  std::string traceid;
  Trace trace_info;

  _MatchDetailRequest__isset __isset;

  void __set_bubble_trace_id(const std::string& val);

  void __set_city_id(const std::string& val);

  void __set_pid(const std::string& val);

  void __set_birth_time(const int64_t val);

  void __set_order_id(const int64_t val);

  void __set_appversion(const std::string& val);

  void __set_extMap(const std::map<std::string, std::string> & val);

  void __set_traceid(const std::string& val);

  void __set_trace_info(const Trace& val);

  bool operator == (const MatchDetailRequest & rhs) const
  {
    if (!(bubble_trace_id == rhs.bubble_trace_id))
      return false;
    if (!(city_id == rhs.city_id))
      return false;
    if (!(pid == rhs.pid))
      return false;
    if (!(birth_time == rhs.birth_time))
      return false;
    if (__isset.order_id != rhs.__isset.order_id)
      return false;
    else if (__isset.order_id && !(order_id == rhs.order_id))
      return false;
    if (__isset.appversion != rhs.__isset.appversion)
      return false;
    else if (__isset.appversion && !(appversion == rhs.appversion))
      return false;
    if (__isset.extMap != rhs.__isset.extMap)
      return false;
    else if (__isset.extMap && !(extMap == rhs.extMap))
      return false;
    if (__isset.traceid != rhs.__isset.traceid)
      return false;
    else if (__isset.traceid && !(traceid == rhs.traceid))
      return false;
    if (__isset.trace_info != rhs.__isset.trace_info)
      return false;
    else if (__isset.trace_info && !(trace_info == rhs.trace_info))
      return false;
    return true;
  }
  bool operator != (const MatchDetailRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MatchDetailRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const MatchDetailRequest& obj);
};

void swap(MatchDetailRequest &a, MatchDetailRequest &b);


class MatchFeature {
 public:

  static const char* ascii_fingerprint; // = "EEBC915CE44901401D881E6091423036";
  static const uint8_t binary_fingerprint[16]; // = {0xEE,0xBC,0x91,0x5C,0xE4,0x49,0x01,0x40,0x1D,0x88,0x1E,0x60,0x91,0x42,0x30,0x36};

  MatchFeature(const MatchFeature&);
  MatchFeature& operator=(const MatchFeature&);
  MatchFeature() : pid(), match_degree(0) {
  }

  virtual ~MatchFeature() throw();
  std::string pid;
  int32_t match_degree;

  void __set_pid(const std::string& val);

  void __set_match_degree(const int32_t val);

  bool operator == (const MatchFeature & rhs) const
  {
    if (!(pid == rhs.pid))
      return false;
    if (!(match_degree == rhs.match_degree))
      return false;
    return true;
  }
  bool operator != (const MatchFeature &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MatchFeature & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const MatchFeature& obj);
};

void swap(MatchFeature &a, MatchFeature &b);

typedef struct _MatchDetailResponse__isset {
  _MatchDetailResponse__isset() : matchFeatureList(false), hold_time(false), elapsed_time(false), rec_status(false) {}
  bool matchFeatureList :1;
  bool hold_time :1;
  bool elapsed_time :1;
  bool rec_status :1;
} _MatchDetailResponse__isset;

class MatchDetailResponse {
 public:

  static const char* ascii_fingerprint; // = "49EA2206E6C12DF2AB0FE74871607CCD";
  static const uint8_t binary_fingerprint[16]; // = {0x49,0xEA,0x22,0x06,0xE6,0xC1,0x2D,0xF2,0xAB,0x0F,0xE7,0x48,0x71,0x60,0x7C,0xCD};

  MatchDetailResponse(const MatchDetailResponse&);
  MatchDetailResponse& operator=(const MatchDetailResponse&);
  MatchDetailResponse() : error_code(0), error_msg(), hold_time(0), elapsed_time(0), rec_status(0) {
  }

  virtual ~MatchDetailResponse() throw();
  int32_t error_code;
  std::string error_msg;
  std::vector<MatchFeature>  matchFeatureList;
  int32_t hold_time;
  int32_t elapsed_time;
  int32_t rec_status;

  _MatchDetailResponse__isset __isset;

  void __set_error_code(const int32_t val);

  void __set_error_msg(const std::string& val);

  void __set_matchFeatureList(const std::vector<MatchFeature> & val);

  void __set_hold_time(const int32_t val);

  void __set_elapsed_time(const int32_t val);

  void __set_rec_status(const int32_t val);

  bool operator == (const MatchDetailResponse & rhs) const
  {
    if (!(error_code == rhs.error_code))
      return false;
    if (!(error_msg == rhs.error_msg))
      return false;
    if (__isset.matchFeatureList != rhs.__isset.matchFeatureList)
      return false;
    else if (__isset.matchFeatureList && !(matchFeatureList == rhs.matchFeatureList))
      return false;
    if (__isset.hold_time != rhs.__isset.hold_time)
      return false;
    else if (__isset.hold_time && !(hold_time == rhs.hold_time))
      return false;
    if (__isset.elapsed_time != rhs.__isset.elapsed_time)
      return false;
    else if (__isset.elapsed_time && !(elapsed_time == rhs.elapsed_time))
      return false;
    if (__isset.rec_status != rhs.__isset.rec_status)
      return false;
    else if (__isset.rec_status && !(rec_status == rhs.rec_status))
      return false;
    return true;
  }
  bool operator != (const MatchDetailResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MatchDetailResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const MatchDetailResponse& obj);
};

void swap(MatchDetailResponse &a, MatchDetailResponse &b);

typedef struct _GetForecastFeatureRequest__isset {
  _GetForecastFeatureRequest__isset() : city_id(false), pid(false), phone(false), extMap(false), traceid(false), spanid(false), trace_info(false) {}
  bool city_id :1;
  bool pid :1;
  bool phone :1;
  bool extMap :1;
  bool traceid :1;
  bool spanid :1;
  bool trace_info :1;
} _GetForecastFeatureRequest__isset;

class GetForecastFeatureRequest {
 public:

  static const char* ascii_fingerprint; // = "81BDF964530F39EA5DCFC9FA57876887";
  static const uint8_t binary_fingerprint[16]; // = {0x81,0xBD,0xF9,0x64,0x53,0x0F,0x39,0xEA,0x5D,0xCF,0xC9,0xFA,0x57,0x87,0x68,0x87};

  GetForecastFeatureRequest(const GetForecastFeatureRequest&);
  GetForecastFeatureRequest& operator=(const GetForecastFeatureRequest&);
  GetForecastFeatureRequest() : bubble_trace_id(), city_id(0), pid(), phone(), traceid(), spanid() {
  }

  virtual ~GetForecastFeatureRequest() throw();
  std::string bubble_trace_id;
  int32_t city_id;
  std::string pid;
  std::string phone;
  std::map<std::string, std::string>  extMap;
  std::string traceid;
  std::string spanid;
  Trace trace_info;

  _GetForecastFeatureRequest__isset __isset;

  void __set_bubble_trace_id(const std::string& val);

  void __set_city_id(const int32_t val);

  void __set_pid(const std::string& val);

  void __set_phone(const std::string& val);

  void __set_extMap(const std::map<std::string, std::string> & val);

  void __set_traceid(const std::string& val);

  void __set_spanid(const std::string& val);

  void __set_trace_info(const Trace& val);

  bool operator == (const GetForecastFeatureRequest & rhs) const
  {
    if (!(bubble_trace_id == rhs.bubble_trace_id))
      return false;
    if (__isset.city_id != rhs.__isset.city_id)
      return false;
    else if (__isset.city_id && !(city_id == rhs.city_id))
      return false;
    if (__isset.pid != rhs.__isset.pid)
      return false;
    else if (__isset.pid && !(pid == rhs.pid))
      return false;
    if (__isset.phone != rhs.__isset.phone)
      return false;
    else if (__isset.phone && !(phone == rhs.phone))
      return false;
    if (__isset.extMap != rhs.__isset.extMap)
      return false;
    else if (__isset.extMap && !(extMap == rhs.extMap))
      return false;
    if (__isset.traceid != rhs.__isset.traceid)
      return false;
    else if (__isset.traceid && !(traceid == rhs.traceid))
      return false;
    if (__isset.spanid != rhs.__isset.spanid)
      return false;
    else if (__isset.spanid && !(spanid == rhs.spanid))
      return false;
    if (__isset.trace_info != rhs.__isset.trace_info)
      return false;
    else if (__isset.trace_info && !(trace_info == rhs.trace_info))
      return false;
    return true;
  }
  bool operator != (const GetForecastFeatureRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetForecastFeatureRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const GetForecastFeatureRequest& obj);
};

void swap(GetForecastFeatureRequest &a, GetForecastFeatureRequest &b);


class GetForecastFeatureResponse {
 public:

  static const char* ascii_fingerprint; // = "CF8E34C3B013B8FBCDA7987E6BC40786";
  static const uint8_t binary_fingerprint[16]; // = {0xCF,0x8E,0x34,0xC3,0xB0,0x13,0xB8,0xFB,0xCD,0xA7,0x98,0x7E,0x6B,0xC4,0x07,0x86};

  GetForecastFeatureResponse(const GetForecastFeatureResponse&);
  GetForecastFeatureResponse& operator=(const GetForecastFeatureResponse&);
  GetForecastFeatureResponse() : error_code(0), error_msg() {
  }

  virtual ~GetForecastFeatureResponse() throw();
  int32_t error_code;
  std::string error_msg;
  std::map<std::string, double>  forecastFeature;

  void __set_error_code(const int32_t val);

  void __set_error_msg(const std::string& val);

  void __set_forecastFeature(const std::map<std::string, double> & val);

  bool operator == (const GetForecastFeatureResponse & rhs) const
  {
    if (!(error_code == rhs.error_code))
      return false;
    if (!(error_msg == rhs.error_msg))
      return false;
    if (!(forecastFeature == rhs.forecastFeature))
      return false;
    return true;
  }
  bool operator != (const GetForecastFeatureResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetForecastFeatureResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const GetForecastFeatureResponse& obj);
};

void swap(GetForecastFeatureResponse &a, GetForecastFeatureResponse &b);

typedef struct _ProductType__isset {
  _ProductType__isset() : product_id(false), combo_type(false), require_level(false) {}
  bool product_id :1;
  bool combo_type :1;
  bool require_level :1;
} _ProductType__isset;

class ProductType {
 public:

  static const char* ascii_fingerprint; // = "D0B01547DD71CCE7ED280A08ECC7D976";
  static const uint8_t binary_fingerprint[16]; // = {0xD0,0xB0,0x15,0x47,0xDD,0x71,0xCC,0xE7,0xED,0x28,0x0A,0x08,0xEC,0xC7,0xD9,0x76};

  ProductType(const ProductType&);
  ProductType& operator=(const ProductType&);
  ProductType() : product_id(), combo_type(0), require_level() {
  }

  virtual ~ProductType() throw();
  std::string product_id;
  int16_t combo_type;
  std::string require_level;

  _ProductType__isset __isset;

  void __set_product_id(const std::string& val);

  void __set_combo_type(const int16_t val);

  void __set_require_level(const std::string& val);

  bool operator == (const ProductType & rhs) const
  {
    if (__isset.product_id != rhs.__isset.product_id)
      return false;
    else if (__isset.product_id && !(product_id == rhs.product_id))
      return false;
    if (__isset.combo_type != rhs.__isset.combo_type)
      return false;
    else if (__isset.combo_type && !(combo_type == rhs.combo_type))
      return false;
    if (__isset.require_level != rhs.__isset.require_level)
      return false;
    else if (__isset.require_level && !(require_level == rhs.require_level))
      return false;
    return true;
  }
  bool operator != (const ProductType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ProductType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ProductType& obj);
};

void swap(ProductType &a, ProductType &b);

typedef struct _PrematchhHoldInfoRequest__isset {
  _PrematchhHoldInfoRequest__isset() : extMap(false), productReq(false), trace_info(false) {}
  bool extMap :1;
  bool productReq :1;
  bool trace_info :1;
} _PrematchhHoldInfoRequest__isset;

class PrematchhHoldInfoRequest {
 public:

  static const char* ascii_fingerprint; // = "3861F858192D6B6A45683E26B12CC16C";
  static const uint8_t binary_fingerprint[16]; // = {0x38,0x61,0xF8,0x58,0x19,0x2D,0x6B,0x6A,0x45,0x68,0x3E,0x26,0xB1,0x2C,0xC1,0x6C};

  PrematchhHoldInfoRequest(const PrematchhHoldInfoRequest&);
  PrematchhHoldInfoRequest& operator=(const PrematchhHoldInfoRequest&);
  PrematchhHoldInfoRequest() : phone(), pid(), city_id(0), cur_lng(0), cur_lat(0), start_lng(0), start_lat(0), start_name(), dest_lng(0), dest_lat(0), dest_name(), traceid() {
  }

  virtual ~PrematchhHoldInfoRequest() throw();
  std::string phone;
  std::string pid;
  int32_t city_id;
  double cur_lng;
  double cur_lat;
  double start_lng;
  double start_lat;
  std::string start_name;
  double dest_lng;
  double dest_lat;
  std::string dest_name;
  std::string traceid;
  std::map<std::string, std::string>  extMap;
  std::vector<ProductType>  productReq;
  Trace trace_info;

  _PrematchhHoldInfoRequest__isset __isset;

  void __set_phone(const std::string& val);

  void __set_pid(const std::string& val);

  void __set_city_id(const int32_t val);

  void __set_cur_lng(const double val);

  void __set_cur_lat(const double val);

  void __set_start_lng(const double val);

  void __set_start_lat(const double val);

  void __set_start_name(const std::string& val);

  void __set_dest_lng(const double val);

  void __set_dest_lat(const double val);

  void __set_dest_name(const std::string& val);

  void __set_traceid(const std::string& val);

  void __set_extMap(const std::map<std::string, std::string> & val);

  void __set_productReq(const std::vector<ProductType> & val);

  void __set_trace_info(const Trace& val);

  bool operator == (const PrematchhHoldInfoRequest & rhs) const
  {
    if (!(phone == rhs.phone))
      return false;
    if (!(pid == rhs.pid))
      return false;
    if (!(city_id == rhs.city_id))
      return false;
    if (!(cur_lng == rhs.cur_lng))
      return false;
    if (!(cur_lat == rhs.cur_lat))
      return false;
    if (!(start_lng == rhs.start_lng))
      return false;
    if (!(start_lat == rhs.start_lat))
      return false;
    if (!(start_name == rhs.start_name))
      return false;
    if (!(dest_lng == rhs.dest_lng))
      return false;
    if (!(dest_lat == rhs.dest_lat))
      return false;
    if (!(dest_name == rhs.dest_name))
      return false;
    if (!(traceid == rhs.traceid))
      return false;
    if (__isset.extMap != rhs.__isset.extMap)
      return false;
    else if (__isset.extMap && !(extMap == rhs.extMap))
      return false;
    if (__isset.productReq != rhs.__isset.productReq)
      return false;
    else if (__isset.productReq && !(productReq == rhs.productReq))
      return false;
    if (__isset.trace_info != rhs.__isset.trace_info)
      return false;
    else if (__isset.trace_info && !(trace_info == rhs.trace_info))
      return false;
    return true;
  }
  bool operator != (const PrematchhHoldInfoRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PrematchhHoldInfoRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const PrematchhHoldInfoRequest& obj);
};

void swap(PrematchhHoldInfoRequest &a, PrematchhHoldInfoRequest &b);

typedef struct _PrematchHoldRes__isset {
  _PrematchHoldRes__isset() : require_level(false), hold_time(false), hit_hold(false), hold_time_select(false), product_info(false) {}
  bool require_level :1;
  bool hold_time :1;
  bool hit_hold :1;
  bool hold_time_select :1;
  bool product_info :1;
} _PrematchHoldRes__isset;

class PrematchHoldRes {
 public:

  static const char* ascii_fingerprint; // = "461F16B34D7D3641D7570A1F391C6993";
  static const uint8_t binary_fingerprint[16]; // = {0x46,0x1F,0x16,0xB3,0x4D,0x7D,0x36,0x41,0xD7,0x57,0x0A,0x1F,0x39,0x1C,0x69,0x93};

  PrematchHoldRes(const PrematchHoldRes&);
  PrematchHoldRes& operator=(const PrematchHoldRes&);
  PrematchHoldRes() : error_code(0), error_msg(), require_level(), hold_time(0), hit_hold(0), hold_time_select(0) {
  }

  virtual ~PrematchHoldRes() throw();
  int32_t error_code;
  std::string error_msg;
  std::string require_level;
  int32_t hold_time;
  int32_t hit_hold;
  int32_t hold_time_select;
  ProductType product_info;

  _PrematchHoldRes__isset __isset;

  void __set_error_code(const int32_t val);

  void __set_error_msg(const std::string& val);

  void __set_require_level(const std::string& val);

  void __set_hold_time(const int32_t val);

  void __set_hit_hold(const int32_t val);

  void __set_hold_time_select(const int32_t val);

  void __set_product_info(const ProductType& val);

  bool operator == (const PrematchHoldRes & rhs) const
  {
    if (!(error_code == rhs.error_code))
      return false;
    if (!(error_msg == rhs.error_msg))
      return false;
    if (__isset.require_level != rhs.__isset.require_level)
      return false;
    else if (__isset.require_level && !(require_level == rhs.require_level))
      return false;
    if (__isset.hold_time != rhs.__isset.hold_time)
      return false;
    else if (__isset.hold_time && !(hold_time == rhs.hold_time))
      return false;
    if (__isset.hit_hold != rhs.__isset.hit_hold)
      return false;
    else if (__isset.hit_hold && !(hit_hold == rhs.hit_hold))
      return false;
    if (__isset.hold_time_select != rhs.__isset.hold_time_select)
      return false;
    else if (__isset.hold_time_select && !(hold_time_select == rhs.hold_time_select))
      return false;
    if (__isset.product_info != rhs.__isset.product_info)
      return false;
    else if (__isset.product_info && !(product_info == rhs.product_info))
      return false;
    return true;
  }
  bool operator != (const PrematchHoldRes &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PrematchHoldRes & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const PrematchHoldRes& obj);
};

void swap(PrematchHoldRes &a, PrematchHoldRes &b);

typedef struct _PrematchhHoldInfoResponse__isset {
  _PrematchhHoldInfoResponse__isset() : hold_time(false), hit_hold(false), hold_time_select(false), holdResults(false) {}
  bool hold_time :1;
  bool hit_hold :1;
  bool hold_time_select :1;
  bool holdResults :1;
} _PrematchhHoldInfoResponse__isset;

class PrematchhHoldInfoResponse {
 public:

  static const char* ascii_fingerprint; // = "80CE7C4CC30B155F3642BCB53BD22EDC";
  static const uint8_t binary_fingerprint[16]; // = {0x80,0xCE,0x7C,0x4C,0xC3,0x0B,0x15,0x5F,0x36,0x42,0xBC,0xB5,0x3B,0xD2,0x2E,0xDC};

  PrematchhHoldInfoResponse(const PrematchhHoldInfoResponse&);
  PrematchhHoldInfoResponse& operator=(const PrematchhHoldInfoResponse&);
  PrematchhHoldInfoResponse() : error_code(0), error_msg(), hold_time(0), hit_hold(0), hold_time_select(0) {
  }

  virtual ~PrematchhHoldInfoResponse() throw();
  int32_t error_code;
  std::string error_msg;
  int32_t hold_time;
  int32_t hit_hold;
  int32_t hold_time_select;
  std::vector<PrematchHoldRes>  holdResults;

  _PrematchhHoldInfoResponse__isset __isset;

  void __set_error_code(const int32_t val);

  void __set_error_msg(const std::string& val);

  void __set_hold_time(const int32_t val);

  void __set_hit_hold(const int32_t val);

  void __set_hold_time_select(const int32_t val);

  void __set_holdResults(const std::vector<PrematchHoldRes> & val);

  bool operator == (const PrematchhHoldInfoResponse & rhs) const
  {
    if (!(error_code == rhs.error_code))
      return false;
    if (!(error_msg == rhs.error_msg))
      return false;
    if (__isset.hold_time != rhs.__isset.hold_time)
      return false;
    else if (__isset.hold_time && !(hold_time == rhs.hold_time))
      return false;
    if (__isset.hit_hold != rhs.__isset.hit_hold)
      return false;
    else if (__isset.hit_hold && !(hit_hold == rhs.hit_hold))
      return false;
    if (__isset.hold_time_select != rhs.__isset.hold_time_select)
      return false;
    else if (__isset.hold_time_select && !(hold_time_select == rhs.hold_time_select))
      return false;
    if (__isset.holdResults != rhs.__isset.holdResults)
      return false;
    else if (__isset.holdResults && !(holdResults == rhs.holdResults))
      return false;
    return true;
  }
  bool operator != (const PrematchhHoldInfoResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PrematchhHoldInfoResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const PrematchhHoldInfoResponse& obj);
};

void swap(PrematchhHoldInfoResponse &a, PrematchhHoldInfoResponse &b);

typedef struct _PrematchStationRes__isset {
  _PrematchStationRes__isset() : extMap(false) {}
  bool extMap :1;
} _PrematchStationRes__isset;

class PrematchStationRes {
 public:

  static const char* ascii_fingerprint; // = "6CCB2F9AE479B85CF77CF44D9A7252ED";
  static const uint8_t binary_fingerprint[16]; // = {0x6C,0xCB,0x2F,0x9A,0xE4,0x79,0xB8,0x5C,0xF7,0x7C,0xF4,0x4D,0x9A,0x72,0x52,0xED};

  PrematchStationRes(const PrematchStationRes&);
  PrematchStationRes& operator=(const PrematchStationRes&);
  PrematchStationRes() : error_code(0), error_msg() {
  }

  virtual ~PrematchStationRes() throw();
  int32_t error_code;
  std::string error_msg;
  ProductType product_info;
  std::vector<StationInfo>  station_list;
  std::map<std::string, std::string>  extMap;

  _PrematchStationRes__isset __isset;

  void __set_error_code(const int32_t val);

  void __set_error_msg(const std::string& val);

  void __set_product_info(const ProductType& val);

  void __set_station_list(const std::vector<StationInfo> & val);

  void __set_extMap(const std::map<std::string, std::string> & val);

  bool operator == (const PrematchStationRes & rhs) const
  {
    if (!(error_code == rhs.error_code))
      return false;
    if (!(error_msg == rhs.error_msg))
      return false;
    if (!(product_info == rhs.product_info))
      return false;
    if (!(station_list == rhs.station_list))
      return false;
    if (__isset.extMap != rhs.__isset.extMap)
      return false;
    else if (__isset.extMap && !(extMap == rhs.extMap))
      return false;
    return true;
  }
  bool operator != (const PrematchStationRes &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PrematchStationRes & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const PrematchStationRes& obj);
};

void swap(PrematchStationRes &a, PrematchStationRes &b);

typedef struct _PrematchEtdRes__isset {
  _PrematchEtdRes__isset() : extMap(false) {}
  bool extMap :1;
} _PrematchEtdRes__isset;

class PrematchEtdRes {
 public:

  static const char* ascii_fingerprint; // = "A467D19E8DDF71D3CBBF4E7844FF520C";
  static const uint8_t binary_fingerprint[16]; // = {0xA4,0x67,0xD1,0x9E,0x8D,0xDF,0x71,0xD3,0xCB,0xBF,0x4E,0x78,0x44,0xFF,0x52,0x0C};

  PrematchEtdRes(const PrematchEtdRes&);
  PrematchEtdRes& operator=(const PrematchEtdRes&);
  PrematchEtdRes() : error_code(0), error_msg() {
  }

  virtual ~PrematchEtdRes() throw();
  int32_t error_code;
  std::string error_msg;
  ProductType product_info;
  CarpoolEtdInfo etd_info;
  std::map<std::string, std::string>  extMap;

  _PrematchEtdRes__isset __isset;

  void __set_error_code(const int32_t val);

  void __set_error_msg(const std::string& val);

  void __set_product_info(const ProductType& val);

  void __set_etd_info(const CarpoolEtdInfo& val);

  void __set_extMap(const std::map<std::string, std::string> & val);

  bool operator == (const PrematchEtdRes & rhs) const
  {
    if (!(error_code == rhs.error_code))
      return false;
    if (!(error_msg == rhs.error_msg))
      return false;
    if (!(product_info == rhs.product_info))
      return false;
    if (!(etd_info == rhs.etd_info))
      return false;
    if (__isset.extMap != rhs.__isset.extMap)
      return false;
    else if (__isset.extMap && !(extMap == rhs.extMap))
      return false;
    return true;
  }
  bool operator != (const PrematchEtdRes &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PrematchEtdRes & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const PrematchEtdRes& obj);
};

void swap(PrematchEtdRes &a, PrematchEtdRes &b);

typedef struct _PrematchRecommendRequest__isset {
  _PrematchRecommendRequest__isset() : extMap(false), productReq(false), trace_info(false) {}
  bool extMap :1;
  bool productReq :1;
  bool trace_info :1;
} _PrematchRecommendRequest__isset;

class PrematchRecommendRequest {
 public:

  static const char* ascii_fingerprint; // = "3861F858192D6B6A45683E26B12CC16C";
  static const uint8_t binary_fingerprint[16]; // = {0x38,0x61,0xF8,0x58,0x19,0x2D,0x6B,0x6A,0x45,0x68,0x3E,0x26,0xB1,0x2C,0xC1,0x6C};

  PrematchRecommendRequest(const PrematchRecommendRequest&);
  PrematchRecommendRequest& operator=(const PrematchRecommendRequest&);
  PrematchRecommendRequest() : phone(), pid(), city_id(0), cur_lng(0), cur_lat(0), start_lng(0), start_lat(0), start_name(), dest_lng(0), dest_lat(0), dest_name(), traceid() {
  }

  virtual ~PrematchRecommendRequest() throw();
  std::string phone;
  std::string pid;
  int32_t city_id;
  double cur_lng;
  double cur_lat;
  double start_lng;
  double start_lat;
  std::string start_name;
  double dest_lng;
  double dest_lat;
  std::string dest_name;
  std::string traceid;
  std::map<std::string, std::string>  extMap;
  std::vector<ProductType>  productReq;
  Trace trace_info;

  _PrematchRecommendRequest__isset __isset;

  void __set_phone(const std::string& val);

  void __set_pid(const std::string& val);

  void __set_city_id(const int32_t val);

  void __set_cur_lng(const double val);

  void __set_cur_lat(const double val);

  void __set_start_lng(const double val);

  void __set_start_lat(const double val);

  void __set_start_name(const std::string& val);

  void __set_dest_lng(const double val);

  void __set_dest_lat(const double val);

  void __set_dest_name(const std::string& val);

  void __set_traceid(const std::string& val);

  void __set_extMap(const std::map<std::string, std::string> & val);

  void __set_productReq(const std::vector<ProductType> & val);

  void __set_trace_info(const Trace& val);

  bool operator == (const PrematchRecommendRequest & rhs) const
  {
    if (!(phone == rhs.phone))
      return false;
    if (!(pid == rhs.pid))
      return false;
    if (!(city_id == rhs.city_id))
      return false;
    if (!(cur_lng == rhs.cur_lng))
      return false;
    if (!(cur_lat == rhs.cur_lat))
      return false;
    if (!(start_lng == rhs.start_lng))
      return false;
    if (!(start_lat == rhs.start_lat))
      return false;
    if (!(start_name == rhs.start_name))
      return false;
    if (!(dest_lng == rhs.dest_lng))
      return false;
    if (!(dest_lat == rhs.dest_lat))
      return false;
    if (!(dest_name == rhs.dest_name))
      return false;
    if (!(traceid == rhs.traceid))
      return false;
    if (__isset.extMap != rhs.__isset.extMap)
      return false;
    else if (__isset.extMap && !(extMap == rhs.extMap))
      return false;
    if (__isset.productReq != rhs.__isset.productReq)
      return false;
    else if (__isset.productReq && !(productReq == rhs.productReq))
      return false;
    if (__isset.trace_info != rhs.__isset.trace_info)
      return false;
    else if (__isset.trace_info && !(trace_info == rhs.trace_info))
      return false;
    return true;
  }
  bool operator != (const PrematchRecommendRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PrematchRecommendRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const PrematchRecommendRequest& obj);
};

void swap(PrematchRecommendRequest &a, PrematchRecommendRequest &b);

typedef struct _PrematchRecommendResponse__isset {
  _PrematchRecommendResponse__isset() : holdResults(false), stationResults(false), etdResults(false), extMap(false) {}
  bool holdResults :1;
  bool stationResults :1;
  bool etdResults :1;
  bool extMap :1;
} _PrematchRecommendResponse__isset;

class PrematchRecommendResponse {
 public:

  static const char* ascii_fingerprint; // = "4BD7067BDAE2114B8F05A72993EC3963";
  static const uint8_t binary_fingerprint[16]; // = {0x4B,0xD7,0x06,0x7B,0xDA,0xE2,0x11,0x4B,0x8F,0x05,0xA7,0x29,0x93,0xEC,0x39,0x63};

  PrematchRecommendResponse(const PrematchRecommendResponse&);
  PrematchRecommendResponse& operator=(const PrematchRecommendResponse&);
  PrematchRecommendResponse() : error_code(0), error_msg() {
  }

  virtual ~PrematchRecommendResponse() throw();
  int32_t error_code;
  std::string error_msg;
  std::vector<PrematchHoldRes>  holdResults;
  std::vector<PrematchStationRes>  stationResults;
  std::vector<PrematchEtdRes>  etdResults;
  std::map<std::string, std::string>  extMap;

  _PrematchRecommendResponse__isset __isset;

  void __set_error_code(const int32_t val);

  void __set_error_msg(const std::string& val);

  void __set_holdResults(const std::vector<PrematchHoldRes> & val);

  void __set_stationResults(const std::vector<PrematchStationRes> & val);

  void __set_etdResults(const std::vector<PrematchEtdRes> & val);

  void __set_extMap(const std::map<std::string, std::string> & val);

  bool operator == (const PrematchRecommendResponse & rhs) const
  {
    if (!(error_code == rhs.error_code))
      return false;
    if (!(error_msg == rhs.error_msg))
      return false;
    if (__isset.holdResults != rhs.__isset.holdResults)
      return false;
    else if (__isset.holdResults && !(holdResults == rhs.holdResults))
      return false;
    if (__isset.stationResults != rhs.__isset.stationResults)
      return false;
    else if (__isset.stationResults && !(stationResults == rhs.stationResults))
      return false;
    if (__isset.etdResults != rhs.__isset.etdResults)
      return false;
    else if (__isset.etdResults && !(etdResults == rhs.etdResults))
      return false;
    if (__isset.extMap != rhs.__isset.extMap)
      return false;
    else if (__isset.extMap && !(extMap == rhs.extMap))
      return false;
    return true;
  }
  bool operator != (const PrematchRecommendResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PrematchRecommendResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const PrematchRecommendResponse& obj);
};

void swap(PrematchRecommendResponse &a, PrematchRecommendResponse &b);

typedef struct _CarpoolEtdRequest__isset {
  _CarpoolEtdRequest__isset() : ext_info(false) {}
  bool ext_info :1;
} _CarpoolEtdRequest__isset;

class CarpoolEtdRequest {
 public:

  static const char* ascii_fingerprint; // = "E67DD0853DD071156D9CB39CCCC5830A";
  static const uint8_t binary_fingerprint[16]; // = {0xE6,0x7D,0xD0,0x85,0x3D,0xD0,0x71,0x15,0x6D,0x9C,0xB3,0x9C,0xCC,0xC5,0x83,0x0A};

  CarpoolEtdRequest(const CarpoolEtdRequest&);
  CarpoolEtdRequest& operator=(const CarpoolEtdRequest&);
  CarpoolEtdRequest() : bubble_id(), express_etd(0), city_id(0), phone(), pid() {
  }

  virtual ~CarpoolEtdRequest() throw();
  Trace trace_info;
  std::string bubble_id;
  int64_t express_etd;
  int32_t city_id;
  std::string phone;
  std::string pid;
  std::map<std::string, std::string>  ext_info;

  _CarpoolEtdRequest__isset __isset;

  void __set_trace_info(const Trace& val);

  void __set_bubble_id(const std::string& val);

  void __set_express_etd(const int64_t val);

  void __set_city_id(const int32_t val);

  void __set_phone(const std::string& val);

  void __set_pid(const std::string& val);

  void __set_ext_info(const std::map<std::string, std::string> & val);

  bool operator == (const CarpoolEtdRequest & rhs) const
  {
    if (!(trace_info == rhs.trace_info))
      return false;
    if (!(bubble_id == rhs.bubble_id))
      return false;
    if (!(express_etd == rhs.express_etd))
      return false;
    if (!(city_id == rhs.city_id))
      return false;
    if (!(phone == rhs.phone))
      return false;
    if (!(pid == rhs.pid))
      return false;
    if (__isset.ext_info != rhs.__isset.ext_info)
      return false;
    else if (__isset.ext_info && !(ext_info == rhs.ext_info))
      return false;
    return true;
  }
  bool operator != (const CarpoolEtdRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CarpoolEtdRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const CarpoolEtdRequest& obj);
};

void swap(CarpoolEtdRequest &a, CarpoolEtdRequest &b);

typedef struct _CarpoolEtdResponse__isset {
  _CarpoolEtdResponse__isset() : ext_info(false) {}
  bool ext_info :1;
} _CarpoolEtdResponse__isset;

class CarpoolEtdResponse {
 public:

  static const char* ascii_fingerprint; // = "047202887E904B4368A0B4D880793D94";
  static const uint8_t binary_fingerprint[16]; // = {0x04,0x72,0x02,0x88,0x7E,0x90,0x4B,0x43,0x68,0xA0,0xB4,0xD8,0x80,0x79,0x3D,0x94};

  CarpoolEtdResponse(const CarpoolEtdResponse&);
  CarpoolEtdResponse& operator=(const CarpoolEtdResponse&);
  CarpoolEtdResponse() : error_code(0), error_msg() {
  }

  virtual ~CarpoolEtdResponse() throw();
  int32_t error_code;
  std::string error_msg;
  CarpoolEtdInfo carpool_etd;
  std::map<std::string, std::string>  ext_info;

  _CarpoolEtdResponse__isset __isset;

  void __set_error_code(const int32_t val);

  void __set_error_msg(const std::string& val);

  void __set_carpool_etd(const CarpoolEtdInfo& val);

  void __set_ext_info(const std::map<std::string, std::string> & val);

  bool operator == (const CarpoolEtdResponse & rhs) const
  {
    if (!(error_code == rhs.error_code))
      return false;
    if (!(error_msg == rhs.error_msg))
      return false;
    if (!(carpool_etd == rhs.carpool_etd))
      return false;
    if (__isset.ext_info != rhs.__isset.ext_info)
      return false;
    else if (__isset.ext_info && !(ext_info == rhs.ext_info))
      return false;
    return true;
  }
  bool operator != (const CarpoolEtdResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CarpoolEtdResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const CarpoolEtdResponse& obj);
};

void swap(CarpoolEtdResponse &a, CarpoolEtdResponse &b);

}} // namespace

#endif
